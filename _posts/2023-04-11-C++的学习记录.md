---
layout: post
read_time: true
show_date: true
title:  C++的学习记录
date:   2023-04-11 16:32:20 -0600
description: C++的学习记录
img: posts/20230411/datu.jpg 
tags: [C++]
author: Geoffrey Hou
category: Coding
mathjax: yes
toc: yes # leave empty or erase for no TOC
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

C++的学习记录。


# 1 从C到C++

## 1.4 C++命名空间（名字空间）详解

namespace 是C++中的关键字，用来定义一个命名空间，语法格式为：

```c++
namespace name{
    //variables, functions, classes
}
```

```c++
Li::fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han::fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
```

`::`是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。

采用 u[sin](http://c.biancheng.net/ref/sin.html)g 关键字声明：

```c++
using Li::fp;
fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han :: fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
```

## 1.5 C++头文件和std命名空间（精辟）

下面是我总结的 C++ 头文件的现状：
\1) 旧的 C++ 头文件，如 iostream.h、fstream.h 等将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在命名空间 std 中。

\2) 新的 C++ 头文件，如 iostream、fstream 等包含的基本功能和对应的旧版头文件相似，但头文件的内容在命名空间 std 中。

> 注意：在标准化的过程中，库中有些部分的细节被修改了，所以旧的头文件和新的头文件不一定完全对应。

\3) 标准C头文件如 stdio.h、stdlib.h 等继续被支持。头文件的内容不在 std 中。

\4) 具有C库功能的新C++头文件具有如 cstdio、cstdlib 这样的名字。它们提供的内容和相应的旧的C头文件相同，只是内容在 std 中。

可以发现，对于不带`.h`的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；对于带`.h`的头文件，没有使用任何命名空间，所有符号都位于全局作用域。这也是 C++ 标准所规定的。

## 1.7 C++变量的定义位置

C89 规定，所有局部变量都必须定义在函数开头，在定义好变量之前不能有其他的执行语句。C99 标准取消这这条限制，但是 VC/VS 对 C99 的支持很不积极，仍然要求变量定义在函数开头。

## 1.8 C++布尔类型（bool）

## 1.9 C++中的const又玩出了新花样

### C++中的 const 更像编译阶段的 #define

C语言对 const 的处理和普通变量一样，会到内存中读取数据；C++ 对 const 的处理更像是编译时期的`#define`，是一个值替换的过程。

### C++中全局 const 变量的可见范围是当前文件

## 1.11 C++ inline内联函数详解

函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。

如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。

**为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开**。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。

**<u>注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。</u>**

当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。

由于内联函数比较短小，我们通常的做法是省略函数原型，将整个函数定义（包括函数头和函数体）放在本应该提供函数原型的地方。

一般只将那些短小的、频繁调用的函数声明为内联函数。

```c
#include <iostream>
using namespace std;

//内联函数，交换两个数的值
inline void swap(int *a, int *b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

int main(){
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap(&m, &n);
    cout<<m<<", "<<n<<endl;

    return 0;
}
```

## 1.12 C++内联函数也可以用来代替宏

宏是可以带参数的，它在形式上和函数非常相似。不过不像函数，宏仅仅是字符串替换，不是按值传递，所以在编写宏时要特别注意，一不小心可能就会踩坑。

```c
#define SQ(y) y*y
#define SQ(y) (y)*(y)
#define SQ(y) ( (y)*(y) )
```

说了这么多，我最终想强调的是，宏定义是一项“细思极密”的工作，一不小心就会踩坑，而且不一定在编译和运行时发现，给程序埋下隐患。

**<u>如果我们将宏替换为内联函数，情况就没有那么复杂了，程序员就会游刃有余</u>**。

```c
inline int SQ(int y){ return y*y; }
```

**<u>所以在编写C++代码时我推荐使用内联函数来替换带参数的宏</u>**。

<u>和宏一样，内联函数可以定义在头文件中（不用加 static 关键字），并且头文件被多次`#include`后也不会引发重复定义错误。这一点和非内联函数不同，非内联函数是禁止定义在头文件中的，它所在的头文件被多次`#include`后会引发重复定义错误。</u>

内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，内联函数更像是编译期间的宏。

综合本节和上节的内容，可以看到内联函数主要有两个作用，一是消除函数调用时的开销，二是取代带参数的宏。不过我更倾向于后者，取代带参数的宏更能凸显内联函数存在的意义。

## 1.13 如何规范地使用C++内联函数

<u>**将内联函数的声明和定义分散到不同的文件中会出错.**</u>

***在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明（声明是多此一举）。***

## 1.14 C++函数的默认参数详解

C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。

## 1.15 到底在声明中还是定义中指定默认参数

上节的例子中，我们在函数定义处指定了默认参数。除了函数定义，你也可以在函数声明处指定默认参数。不过当出现函数声明时情况会变得稍微复杂，有时候你可以在声明处和定义处同时指定默认参数，有时候你只能在声明处指定，请看下面的例子（示例1）：

```c
#include <iostream>
using namespace std;

void func(int a, int b = 10, int c = 36);

int main(){
    func(99);
    return 0;
}

void func(int a, int b = 10, int c = 36){
    cout<<a<<", "<<b<<", "<<c<<endl;
}
```

这段代码在编译时会报错，错误信息表明不能在函数定义和函数声明中同时指定默认参数。对代码稍作修改，将 func() 函数的定义放到其他源文件中，如下所示（示例2）。

main.cpp 代码：

```c
#include <iostream>
using namespace std;

void func(int a, int b = 10, int c = 36);

int main(){
    func(99);
    return 0;
}
```

module.cpp 代码：

```c
#include <iostream>
using namespace std;

void func(int a, int b = 10, int c = 36);

int main(){
    func(99);
    return 0;
}
```

运行结果：
99, 10, 36

修改后的代码是可以编译通过的，这有点让人摸不着头脑，为什么将 func() 的定义放到其他源文件中就不一样了呢？

> 如果读者对多文件编程不了解，请阅读《[C语言多文件编程](http://c.biancheng.net/c/150/)》，C++ 在多文件编程方面仍然在使用C语言的规则。

这是因为C++ 规定，在给定的作用域中只能指定一次默认参数。

对于示例1，func() 的定义和声明位于同一个源文件，它们的作用域也都是整个源文件，这样就导致在同一个文件作用域中指定了两次默认参数，违反了 C++ 的规定。

对于示例2，func() 的声明位于`main.cpp`，作用域也是`main.cpp`，而 func() 的定义位于`module.cpp`，作用域也是`module.cpp`，func() 的声明和定义位于不同的作用域，相互之间不影响。

> C语言有四种作用域，分别是函数原型作用域、局部作用域（函数作用域）、块作用域、文件作用域（全局作用域），C++ 也有这几种作用域。

继续对代码进行修改，将 func() 定义处 b、c 的默认值分别设置为 5、57，而声明处 b、c 的默认值不变，依然为 10、36。编译并运行程序，发现输出结果与上面一样，这说明编译器使用的是当前作用域中的默认参数。站在编译器的角度看，它不管当前作用域中是函数声明还是函数定义，只要有默认参数就可以使用。

### 多次声明同一函数

在多文件编程时，我们通常的做法是将函数声明放在头文件中，并且一个函数只声明一次，但是多次声明同一函数也是合法的。

不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认参数。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认值，而且该形参右侧的所有形参必须都有默认值。

为了说明问题，我们不妨对 main.cpp 中的代码稍作修改：

```c
#include <iostream>
using namespace std;

//多次声明同一个函数
void func(int a, int b, int c = 36);
void func(int a, int b = 5, int c);

int main(){
    func(99);
    return 0;
}
```

这种声明方式是正确的。第一次声明时为 c 指定了默认值，第二次声明时为 b 指定了默认值；第二次声明是添加默认参数。需要提醒的是，第二次声明时不能再次给 c 指定默认参数，否则就是重复声明同一个默认参数。

## 1.16 C++函数重载详解

参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。

注意，参数列表不同包括参数的个数不同、类型不同或顺序不同，仅仅参数名称不同是不可以的。函数返回值也不能作为重载的依据。

### C++ 是如何做到函数重载的

C++代码在编译时会根据参数列表对函数进行重命名，例如`void Swap(int a, int b)`会被重命名为`_Swap_int_int`，`void Swap(float x, float y)`会被重命名为`_Swap_float_float`。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。

> 不同的编译器有不同的重命名方式，这里仅仅举例说明，实际情况可能并非如此。

## 1.17 C++函数重载过程中的二义性和类型转换

上节我们讲到，发生函数调用时编译器会根据传入的实参的个数、类型、顺序等信息去匹配要调用的函数，这在大部分情况下都能够精确匹配。但当实参的类型和形参的类型不一致时情况就会变得稍微复杂，例如函数形参的类型是`int`，调用函数时却将`short`类型的数据交给了它，编译器就需要先将`short`类型转换为`int`类型才能匹配成功。

现在有以下几种形式的函数重载（例1）：

```c
#include <iostream>
using namespace std;

//1号函数
void func(char ch){
    cout<<"#1"<<endl;
}
//2号函数
void func(int n){
    cout<<"#2"<<endl;
}
//3号函数
void func(long m){
    cout<<"#3"<<endl;
}
//4号函数
void func(double f){
    cout<<"#4"<<endl;
}

int main(){
    short s = 99;
    float f = 84.6;
   
    func('a');  //不需要类型转换，调用func(char)
    func(s);  //将short转换成int，调用func(int)
    func(49);  //不需要类型转换，调用func(int)
    func(f);  //将float转换成double，调用func(double)
    return 0;
}
```

运行结果：

\#1
\#2
\#2
\#4

这段代码很容易理解，相信大家都不会有什么疑问。对代码稍作修改，将2号函数`void func(int n)`去掉（例2）：

```c
#include <iostream>
using namespace std;

//1号函数
void func(char ch){
    cout<<"#1"<<endl;
}
//3号函数
void func(long m){
    cout<<"#3"<<endl;
}
//4号函数
void func(double f){
    cout<<"#4"<<endl;
}

int main(){
    short s = 99;
    float f = 84.6;
  
    func('a');
    func(s);
    func(49);
    func(f);
    return 0;
}
```

这段代码在编译时发生了错误，大概的意思是：`func(s)`和`func(49)`这两个函数发生调用错误，它们可以匹配三个重载函数中的任何一个，编译器不知道如何抉择。

这着实有点让人摸不着头脑！根据以往的编程经验，s 和 49 不都应该被转换成 long 类型，从而匹配3号函数`void func(long m)`吗？这种推论在一般的函数调用或者四则运算中确实没错，但它不一定适用于重载函数！

C++ 标准规定，在进行重载决议时编译器应该按照下面的优先级顺序来处理实参的类型：

|         优先级         |                          包含的内容                          |                           举例说明                           |
| :--------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|        精确匹配        |                    不做类型转换，直接匹配                    |                         （暂无说明）                         |
|  只是做微不足道的转换  | 从数组名到数组指针、从函数名到指向函数的指针、从非 const 类型到 const 类型。 |                                                              |
|     类型提升后匹配     |                           整型提升                           | 从 bool、char、short 提升为 int，或者从 char16_t、char32_t、wchar_t 提升为 int、long、long long。 |
|        小数提升        |                   从 float 提升为 double。                   |                                                              |
| 使用自动类型转换后匹配 |                           整型转换                           | 从 char 到 long、short 到 long、int 到 short、long 到 char。 |
|        小数转换        |                     从 double 到 float。                     |                                                              |
|     整数和小数转换     | 从 int 到 double、short 到 float、float 到 int、double 到 long。 |                                                              |
|        指针转换        |                     从 int * 到 void *。                     |                                                              |


C++ 标准还规定，编译器应该按照从高到低的顺序来搜索重载函数，首先是精确匹配，然后是类型提升，最后才是类型转换；一旦在某个优先级中找到唯一的一个重载函数就匹配成功，不再继续往下搜索。

如果在一个优先级中找到多个（两个以及以上）合适的重载函数，编译器就会陷入两难境地，不知道如何抉择，编译器会将这种模棱两可的函数调用视为一种错误，因为这些合适的重载函数同等“优秀”，没有一个脱颖而出，调用谁都一样。这就是函数重载过程中的二义性错误。

在例1中，`func('a')`、`func(49)`分别和`void func(char)`、`void func(int)`精确匹配；`func(s)`没有精确匹配的重载函数，编译器将 s 的类型提升为 int 后和`void func(int)`匹配成功；`func(f)`也是类似的道理，将 f 提升为 double 类型后和`void func(double)`匹配成功。

在例2中，`func(s)`、`func(49)`没有精确匹配的重载函数，将它们的类型都提升为 int 后仍然不能匹配，接下来进入自动类型转换阶段，发现 s 被转换为 char（整型转换）、long（整型转换）、double（整数和小数转换）后都有比较合适的函数，而且它们在同一个优先级中，谁也不比谁优秀，调用哪个都一样，产生了二义性，所以编译器会报错。

注意，类型提升和类型转换不是一码事！类型提升是积极的，是为了更加高效地利用计算机硬件，不会导致数据丢失或精度降低；而类型转换是不得已而为之，不能保证数据的正确性，也不能保证应有的精度。类型提升只有上表中列出的几种情况，其他情况都是类型转换。

### 多个参数时的二义性

当重载函数有多个参数时也会产生二义性，而且情况更加复杂。C++ 标准规定，如果有且只有一个函数满足下列条件，则匹配成功：

- 该函数对每个实参的匹配都不劣于其他函数；
- 至少有一个实参的匹配优于其他函数。


假设现在有以下几个函数原型：

```c
void func(int, int);  //①
void func(char, int, float);  //②
void func(char, long, double);  //③
```

我们来分析如下的调用会发生什么情况：

```c
short n = 99;
func('@', n, 99);
func('@', n, 99.5);
```

函数原型`func(int, int)`只有两个参数，而函数调用有三个参数，很容易看出来不匹配，在初次筛选时就会被过滤掉，接下来我们只讨论②③个函数原型。

\1) 先来看第一个函数调用。如果只考虑第一个实参`'@'`，那么②③两个函数都能够精确匹配，谁也不比谁优秀，是平等的；如果只考虑第二个实参`n`，对于②，需要把 short 提升为 int（类型提升），对于③，需要把 short 转换为 long（类型转换），类型提升的优先级高于类型转换，所以②胜出；如果只考虑第三个实参`99`，②③都要进行类型转换，没有哪一个能胜出，它们是平等的。

从整体上看，②③在第一、三个实参的匹配中是平等的，但②在第二个实参的匹配中胜出，也就是说，②对每个实参的匹配都不劣于③，但有一个实参的匹配优于③，所以②最终脱颖而出，成为被调用函数。

\2) 再来看第二个函数调用。只考虑第一个实参时②③是平等的，没有谁胜出；只考虑第二个实参时②胜出；只考虑第三个实参时，②需要类型转换，③能够精确匹配，精确匹配的优先级高于类型转换，所以③胜出。

从整体上看，②③在第一个实参的匹配中是平等的，②在第二个实参的匹配中胜出，③在第三个实参的匹配中胜出，它们最终“打成了平手”，分不清孰优孰劣，所以编译器不知道如何抉择，会产生二义性错误。

### 总结

在设计重载函数时，参数类型过少或者过多都容易引起二义性错误，因为这些类型相近，彼此之间会相互转换。

例如我们要设计几个重载函数来处理数值，数值包括小数和整数，如果只提供了以下两个函数原型：

```c
void func(int);
void func(double);
```

那么下面的函数调用就会产生二义性错误：

```c
long n = 1000;
func(n);
```

n 是 long 类型，转换为 int 或 double 的优先级都是一样的，编译器不知道如何抉择。

如果添加一个函数原型`void func(long);`，或者去掉一个函数原型`void func(int);`，无论再怎么调用也不会出错了。

## 1.18 如何实现C++和C的混合编程？

C++ 和 C 可以进行混合编程。但需要注意的是，由于 C++ 和 C 在程序的编译、链接等方面都存在一定的差异，而这些差异往往会导致程序运行失败。

举个例子，如下就是一个用 C++ 和 C 混合编程实现的实例项目：

```c
//myfun.h
void display();

//myfun.c
#include <stdio.h>
#include "myfun.h"
void display(){
   printf("C++：http://c.biancheng/net/cplus/");
}

//main.cpp
#include <iostream>
#include "myfun.h"
using namespace std;
int main(){
   display();
   return 0;
}
```

在此项目中，主程序是用 C++ 编写的，而 display() 函数的定义是用 C 语言编写的。从表面上看，这个项目很完整，我们可以尝试运行它：

In function `main': undefined reference to `display()'

如上是调用 GCC 编译器运行此项目时给出的错误信息，指的是编译器无法找到 main.cpp 文件中 display() 函数的实现代码。导致此错误的原因，就是因为 C++ 和 C 编译程序的方式存在差异。

通过学习《[C++函数重载](http://c.biancheng.net/view/2206.html)》一节我们知道，之所以 C++ 支持函数的重载，是因为 C++ 会在程序的编译阶段对函数的函数名进行“再次重命名”，例如：

- void Swap(int a, int b) 会被重命名为`_Swap_int_int`；
- void Swap(float x, float y) 会被重命名为`_Swap_float_float`。

显然通过重命名，可以有效避免编译器在程序链接阶段无法找到对应的函数。

但是，C 语言是不支持函数重载的，它不会在编译阶段对函数的名称做较大的改动。仍以 void Swap(int a, int b) 和 void Swap(float x, float y) 为例，若以 C 语言的标准对它们进行编译，两个函数的函数名将都是`_Swap`。

> 不同的编译器有不同的重命名方式，但根据 C++ 标准编译后的函数名几乎都由原有函数名和各个参数的数据类型构成，而根据 C 语言标准编译后的函数名则仅有原函数名构成。这里仅仅举例说明，实际情况可能并非如此。

这也就意味着，使用 C 和 C++ 进行混合编程时，考虑到对函数名的处理方式不同，势必会造成编译器在程序链接阶段无法找到函数具体的实现，导致链接失败。

幸运的是，C++ 给出了相应的解决方案，即借助 extern "C"，就可以轻松解决 C++ 和 C 在处理代码方式上的差异性。

## extern "C"

extern 是 C 和 C++ 的一个关键字，但对于 extern "C"，读者大可以将其看做一个整体，和 extern 毫无关系。

extern "C" 既可以修饰一句 C++ 代码，也可以修饰一段 C++ 代码，它的功能是让编译器以处理 C 语言代码的方式来处理修饰的 C++ 代码。

仍以本节前面的实例项目来说，main.cpp 和 myfun.c 文件中都包含 myfun.h 头文件，当程序进行预处理操作时，myfun.h 头文件中的内容会被分别复制到这 2 个源文件中。对于 main.cpp 文件中包含的 display() 函数来说，编译器会以 C++ 代码的编译方式来处理它；而对于 myfun.c 文件中的 display() 函数来说，编译器会以 C 语言代码的编译方式来处理它。

为了避免 display() 函数以不同的编译方式处理，我们应该使其在 main.cpp 文件中仍以 C 语言代码的方式处理，这样就可以解决函数名不一致的问题。因此，可以像如下这样来修改 myfun.h：

```c
#ifdef __cplusplus
extern "C" void display();
#else
void display();
#endif
```

可以看到，当 myfun.h 被引入到 C++ 程序中时，会选择带有 extern "C" 修饰的 display() 函数；反之如果 myfun.h 被引入到 C 语言程序中，则会选择不带 extern "C" 修饰的 display() 函数。由此，无论 display() 函数位于 C++ 程序还是 C 语言程序，都保证了 display() 函数可以按照 C 语言的标准来处理。

再次运行该项目，会发现之前的问题消失了，可以正常运行：

C++：http://c.biancheng/net/cplus/


在实际开发中，对于解决 C++ 和 C 混合编程的问题，通常在头文件中使用如下格式：

```c
#ifdef __cplusplus
extern "C" {
#endif

void display();

#ifdef __cplusplus
}
#endif
```

由此可以看出，extern "C" 大致有 2 种用法，当仅修饰一句 C++ 代码时，直接将其添加到该函数代码的开头即可；如果用于修饰一段 C++ 代码，只需为 extern "C" 添加一对大括号`{}`，并将要修饰的代码囊括到括号内即可。

# 2 类和对象

## 2.1 [C++类的定义和对象的创建详解](http://c.biancheng.net/view/2213.html)

类名的首字母一般大写，以和其他的标识符区分开。

注意在类定义的最后有一个分号`;`，它是类定义的一部分，表示类定义结束了，不能省略。

类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。

## 使用对象[指针](http://c.biancheng.net/c/80/)

上面代码中创建的对象 stu 在栈上分配内存，需要使用`&`获取它的地址，例如：

```
Student stu;Student *pStu = &stu;
```

pStu 是一个指针，它指向 Student 类型的数据，也就是通过 Student 创建出来的对象。

当然，你也可以在堆上创建对象，这个时候就需要使用前面讲到的`new`关键字（[C++ new和delete运算符简介](http://c.biancheng.net/view/2199.html)），例如：

```
Student *pStu = new Student;
```

在栈上创建出来的对象都有一个名字，比如 stu，使用指针指向它不是必须的。但是通过 new 创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，**使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数**。

**栈内存是程序自动管理的，不能使用 delete 删除在栈上创建的对象；堆内存由程序员管理，对象使用完毕后可以通过 delete 删除。在实际开发中，new 和 delete 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。**

## 2.2 C++类的成员变量和成员函数详解

### 在类体中和类体外定义成员函数的区别

在类体中和类体外定义成员函数是有区别的：在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。

内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。

## 2.11 C++ this指针详解（精辟）

this 是 [C++](http://c.biancheng.net/cplus/) 中的一个关键字，也是一个 const [指针](http://c.biancheng.net/c/80/)，它指向当前对象，通过它可以访问当前对象的所有成员。

所谓当前对象，是指正在使用的对象。

**注意，this 是一个指针，要用`->`来访问成员变量或成员函数。**

<u>this 只能用在类的内部，通过 this 可以访问类的所有成员，包括 private、protected、public 属性的。</u>

几点注意：

- this 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。
- this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
- 只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用（后续会讲到 static 成员）。

### this 到底是什么

this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。

this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。

## 2.12 C++ static静态成员变量详解

在[C++](http://c.biancheng.net/cplus/)中，我们可以使用静态成员变量来实现**多个对象共享数据**的目标。静态成员变量是一种特殊的成员变量，它被关键字`static`修饰

**static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total 分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了 m_total，也会影响到其他对象**。

**static 成员变量必须在类声明的外部初始化，具体形式为：**

**type class::name = value;**

type 是变量的类型，class 是类名，name 是变量名，value 是初始值。将上面的 m_total 初始化：

int Student::m_total = 0;

**静态成员变量在初始化时不能再加 static**，但必须要有数据类型。被 private、protected、public 修饰的静态成员变量都可以用这种方式初始化。

注意：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。

**static 成员变量既可以通过对象来访问，也可以通过类来访问**。

注意：static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存.

## 几点说明 

\1) 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。

\2) static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。

\3) 静态成员变量必须初始化，而且只能在类体外进行。例如：

int Student::m_total = 10;

初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。

\4) 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。

## 2.13 C++ static静态成员函数详解

普通成员函数可以访问所有成员（包括成员变量和成员函数），**静态成员函数只能访问静态成员**。

<u>**静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。**</u>

<u>在[C++](http://c.biancheng.net/cplus/)中，静态成员函数的主要目的是访问静态成员。</u>

<u>和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用.</u>

## 2.14 C++ const成员变量和成员函数（常成员函数）

初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表.

const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。

我们通常将 get 函数设置为常成员函数。读取成员变量的函数的名字通常以`get`开头，后跟成员变量的名字，所以通常将它们称为 get 函数。

<u>常成员函数需要在声明和定义的时候在**函数头部的结尾**加上 const 关键字</u>

最后再来区分一下 const 的位置：

- 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如`const char * getname()`。
- 函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如`char * getname() const`。

## 2.16 C++友元函数和友元类（C++ friend关键字）

借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。

### 友元函数

在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。

友元函数可以访问当前类中的所有成员，包括 public、protected、private 属性的。

#### 1) 将非成员函数声明为友元函数。

```c
#include <iostream>
using namespace std;

class Student{
public:
    Student(char *name, int age, float score);
public:
    friend void show(Student *pstu);  //将show()声明为友元函数
private:
    char *m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }

//非成员函数
void show(Student *pstu){
    cout<<pstu->m_name<<"的年龄是 "<<pstu->m_age<<"，成绩是 "<<pstu->m_score<<endl;
}

int main(){
    Student stu("小明", 15, 90.6);
    show(&stu);  //调用友元函数
    Student *pstu = new Student("李磊", 16, 80.5);
    show(pstu);  //调用友元函数

    return 0;
}
```

注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。下面的写法是错误的：

```c
void show(){
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是 "<<m_score<<endl;
}
```

成员函数在调用时会隐式地增加 this [指针](http://c.biancheng.net/c/80/)，指向调用它的对象，从而使用该对象的成员；而 show() 是非成员函数，没有 this 指针，编译器不知道使用哪个对象的成员，要想明确这一点，就必须通过参数传递对象（可以直接传递对象，也可以传递对象指针或对象引用），并在访问成员时指明对象。

#### 2) 将其他类的成员函数声明为友元函数

friend 函数不仅可以是全局函数（非成员函数），还可以是另外一个类的成员函数。请看下面的例子：

```c
#include <iostream>
using namespace std;

class Address;  //提前声明Address类

//声明Student类
class Student{
public:
    Student(char *name, int age, float score);
public:
    void show(Address *addr);
private:
    char *m_name;
    int m_age;
    float m_score;
};

//声明Address类
class Address{
private:
    char *m_province;  //省份
    char *m_city;  //城市
    char *m_district;  //区（市区）
public:
    Address(char *province, char *city, char *district);
    //将Student类中的成员函数show()声明为友元函数
    friend void Student::show(Address *addr);
};

//实现Student类
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(Address *addr){
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是 "<<m_score<<endl;
    cout<<"家庭住址："<<addr->m_province<<"省"<<addr->m_city<<"市"<<addr->m_district<<"区"<<endl;
}

//实现Address类
Address::Address(char *province, char *city, char *district){
    m_province = province;
    m_city = city;
    m_district = district;
}

int main(){
    Student stu("小明", 16, 95.5f);
    Address addr("陕西", "西安", "雁塔");
    stu.show(&addr);
   
    Student *pstu = new Student("李磊", 16, 80.5);
    Address *paddr = new Address("河北", "衡水", "桃城");
    pstu -> show(paddr);

    return 0;
}
```

运行结果：
小明的年龄是 16，成绩是 95.5
家庭住址：陕西省西安市雁塔区
李磊的年龄是 16，成绩是 80.5
家庭住址：河北省衡水市桃城区

本例定义了两个类 Student 和 Address，程序第 27 行将 Student 类的成员函数 show() 声明为 Address 类的友元函数，由此，show() 就可以访问 Address 类的 private 成员变量了。

几点注意：
① 程序第 4 行对 Address 类进行了提前声明，是因为在 Address 类定义之前、在 Student 类中使用到了它，如果不提前声明，编译器会报错，提示`'Address' has not been declared`。类的提前声明和函数的提前声明是一个道理。

② 程序将 Student 类的声明和实现分开了，而将 Address 类的声明放在了中间，这是因为编译器从上到下编译代码，show() 函数体中用到了 Address 的成员 province、city、district，如果提前不知道 Address 的具体声明内容，就不能确定 Address 是否拥有该成员（类的声明中指明了类有哪些成员）。

这里简单介绍一下类的提前声明。一般情况下，类必须在正式声明之后才能使用；但是某些情况下（如上例所示），只要做好提前声明，也可以先使用。

但是应当注意，类的提前声明的使用范围是有限的，只有在正式声明一个类以后才能用它去创建对象。如果在上面程序的第4行之后增加如下所示的一条语句，编译器就会报错：

Address addr; //企图使用不完整的类来创建对象

因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），才能确定应该为对象预留多大的内存。在对一个类作了提前声明后，可以用该类的名字去定义指向该类型对象的指针变量（本例就定义了 Address 类的指针变量）或引用变量（后续会介绍引用），因为指针变量和引用变量本身的大小是固定的，与它所指向的数据的大小无关。

③ 一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。

### 友元类

不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。

例如将类 B 声明为类 A 的友元类，那么类 B 中的所有成员函数都是类 A 的友元函数，可以访问类 A 的所有成员，包括 public、protected、private 属性的。

更改上例的代码，将 Student 类声明为 Address 类的友元类：

```c
#include <iostream>
using namespace std;

class Address;  //提前声明Address类

//声明Student类
class Student{
public:
    Student(char *name, int age, float score);
public:
    void show(Address *addr);
private:
    char *m_name;
    int m_age;
    float m_score;
};

//声明Address类
class Address{
public:
    Address(char *province, char *city, char *district);
public:
    //将Student类声明为Address类的友元类
    friend class Student;
private:
    char *m_province;  //省份
    char *m_city;  //城市
    char *m_district;  //区（市区）
};

//实现Student类
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(Address *addr){
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是 "<<m_score<<endl;
    cout<<"家庭住址："<<addr->m_province<<"省"<<addr->m_city<<"市"<<addr->m_district<<"区"<<endl;
}

//实现Address类
Address::Address(char *province, char *city, char *district){
    m_province = province;
    m_city = city;
    m_district = district;
}

int main(){
    Student stu("小明", 16, 95.5f);
    Address addr("陕西", "西安", "雁塔");
    stu.show(&addr);
   
    Student *pstu = new Student("李磊", 16, 80.5);
    Address *paddr = new Address("河北", "衡水", "桃城");
    pstu -> show(paddr);

    return 0;
}
```

第 24 行代码将 Student 类声明为 Address 类的友元类，声明语句为：

friend class Student;

有的编译器也可以不写 class 关键字，不过为了增强兼容性还是建议写上。

关于友元，有两点需要说明：

- 友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。
- 友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。


**除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。**

## 2.18 C++ class和struct到底有什么区别

C++中的 struct 和 class 基本是通用的，唯有几个细节不同：

- 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
- class 继承默认是 private 继承，而 struct 继承默认是 public 继承（《[C++继承与派生](http://c.biancheng.net/cpp/biancheng/cpp/rumen_11/)》一章会讲解继承）。
- class 可以使用模板，而 struct 不能（《[模板、字符串和异常](http://c.biancheng.net/cpp/biancheng/cpp/rumen_14/)》一章会讲解模板）。

在编写C++代码时，我强烈建议使用 class 来定义类，而使用 struct 来定义结构体，这样做语义更加明确。

使用 struct 来定义类的一个反面教材：

```c
#include <iostream>
using namespace std;

struct Student{
    Student(char *name, int age, float score);
    void show();

    char *m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

int main(){
    Student stu("小明", 15, 92.5f);
    stu.show();
    Student *pstu = new Student("李华", 16, 96);
    pstu -> show();

    return 0;
}
```

运行结果：
小明的年龄是15，成绩是92.5
李华的年龄是16，成绩是96

这段代码可以通过编译，说明 struct 默认的成员都是 public 属性的，否则不能通过对象访问成员函数。如果将 struct 关键字替换为 class，那么就会编译报错。

## 2.19 C++ string详解，C++字符串详解

除了可以使用C风格的字符串，还可以使用内置的 string 类。string 类处理起字符串来会方便很多，完全可以代替C语言中的字符数组或字符串[指针](http://c.biancheng.net/c/80/)。

```c
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1;//没有初始化，编译器会将默认值赋给 s1，默认值是""，也即空字符串。
    string s2 = "c plus plus";//与C风格的字符串不同，string 的结尾没有结束标志'\0'。
    string s3 = s2;
    string s4 (5, 's');//初始化为由 5 个's'字符组成的字符串，也就是"sssss"。
    return 0;
}
```

当我们需要知道字符串长度时，可以调用 string 类提供的 **length()** 函数。

```c
string s = "http://c.biancheng.net";
int len = s.length();
cout<<len<<endl;
```

### string 字符串的输入输出

```c
#include <iostream>
#include <string>

using namespace std;

int main(){
    string s;
    cin>>s;  //输入字符串
    cout<<s<<endl;  //输出字符串
    return 0;
}
```

运行结果：
http://c.biancheng.net  http://vip.biancheng.net↙
http://c.biancheng.net

虽然我们输入了两个由空格隔开的网址，但是只输出了一个，这是因为输入**运算符`>>`默认会忽略空格**，遇到空格就认为输入结束，所以最后输入的`http://vip.biancheng.net`没有被存储到变量 s。

### 访问字符串中的字符

string 字符串也可以像C风格的字符串一样按照下标来访问其中的每一个字符。string 字符串的起始下标仍是从 0 开始。请看下面的代码：

```c
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s = "1234567890";
    for(int i=0,len=s.length(); i<len; i++){
        cout<<s[i]<<" ";
    }
    cout<<endl;
    s[5] = '5';
    cout<<s<<endl;
    return 0;
}
```

运行结果：
1 2 3 4 5 6 7 8 9 0
1234557890

本例定义了一个 string 变量 s，并赋值 "1234567890"，之后用 [for 循环](http://c.biancheng.net/view/172.html)遍历输出每一个字符。借助下标，除了能够访问每个字符，也可以修改每个字符，`s[5] = '5';`就将第6个字符修改为 '5'，所以 s 最后为 "1234557890"。

### 字符串的拼接

有了 string 类，我们可以使用`+`或`+=`运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的 strcat()、strcpy()、malloc() 等函数来拼接字符串了，再也不用担心空间不够会溢出了。

用`+`来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个字符数组，或者是一个 string 字符串和一个单独的字符。请看下面的例子：

```c
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1 = "first ";
    string s2 = "second ";
    char *s3 = "third ";
    char s4[] = "fourth ";
    char ch = '@';

    string s5 = s1 + s2;
    string s6 = s1 + s3;
    string s7 = s1 + s4;
    string s8 = s1 + ch;
    
    cout<<s5<<endl<<s6<<endl<<s7<<endl<<s8<<endl;

    return 0;
}
```

运行结果：
first second
first third
first fourth
first @

### string 字符串的增删改查

C++ 提供的 string 类包含了若干实用的成员函数，大大方便了字符串的增加、删除、更改、查询等操作。

#### 一. 插入字符串

insert() 函数可以在 string 字符串中指定的位置插入另一个字符串，它的一种原型为：

```c
string& insert (size_t pos, const string& str);
```

pos 表示要插入的位置，也就是下标；str 表示要插入的字符串，它可以是 string 字符串，也可以是C风格的字符串。

请看下面的代码：

```c
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1, s2, s3;
    s1 = s2 = "1234567890";
    s3 = "aaa";
    s1.insert(5, s3);
    cout<< s1 <<endl;
    s2.insert(5, "bbb");
    cout<< s2 <<endl;
    return 0;
}
```

运行结果：
12345aaa67890
12345bbb67890

**insert() 函数的第一个参数有越界的可能，如果越界，则会产生运行时异常**，我们将会在《[C++异常（Exception）](http://c.biancheng.net/cpp/biancheng/cpp/rumen_16/)》一章中详细讲解如何捕获这个异常。

更多 insert() 函数的原型和用法请参考：http://www.cplusplus.com/reference/string/string/insert/

#### 二. 删除字符串

erase() 函数可以删除 string 中的一个子字符串。它的一种原型为：

```c
string& erase (size_t pos = 0, size_t len = npos);
```

**pos 表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len = str.length - pos）**。

请看下面的代码：

```c
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1, s2, s3;
    s1 = s2 = s3 = "1234567890";
    s2.erase(5);
    s3.erase(5, 3);
    cout<< s1 <<endl;
    cout<< s2 <<endl;
    cout<< s3 <<endl;
    return 0;
}
```

运行结果：
1234567890
12345
1234590

有读者担心，在 pos 参数没有越界的情况下， len 参数也可能会导致要删除的子字符串越界。但实际上这种情况不会发生，erase() 函数会从以下两个值中取出最小的一个作为待删除子字符串的长度：

- len 的值；
- 字符串长度减去 pos 的值。


说得简单一些，待删除字符串最多只能删除到字符串结尾。

#### 三. 提取子字符串

substr() 函数用于从 string 字符串中提取子字符串，它的原型为：

```c
string substr (size_t pos = 0, size_t len = npos) const;
```

pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。

请看下面的代码：

```c
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1 = "first second third";
    string s2;
    s2 = s1.substr(6, 6);
    cout<< s1 <<endl;
    cout<< s2 <<endl;
    return 0;
}
```

运行结果：
first second third
second

系统对 substr() 参数的处理和 erase() 类似：

- 如果 pos 越界，会抛出异常；
- 如果 len 越界，会提取从 pos 到字符串结尾处的所有字符。

#### 四. 字符串查找

string 类提供了几个与字符串查找有关的函数，如下所示。

##### 1) find() 函数

find() 函数用于在 string 字符串中查找子字符串出现的位置，它其中的两种原型为：

```c
size_t find (const string& str, size_t pos = 0) const;
size_t find (const char* s, size_t pos = 0) const;
```

第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。

请看下面的代码：

```c
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1 = "first second third";
    string s2 = "second";
    int index = s1.find(s2,5);
    if(index < s1.length())
        cout<<"Found at index : "<< index <<endl;
    else
        cout<<"Not found"<<endl;
    return 0;
}
```

运行结果：
Found at index : 6

find() 函数最终返回的是子字符串第一次出现在字符串中的起始下标。本例最终是在下标6处找到了 s2 字符串。如果没有查找到子字符串，那么会返回一个无穷大值 4294967295。

##### 2) rfind() 函数

rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。

请看下面的例子：

```c
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1 = "first second third";
    string s2 = "second";
    int index = s1.rfind(s2,6);
    if(index < s1.length())
        cout<<"Found at index : "<< index <<endl;
    else
        cout<<"Not found"<<endl;
    return 0;
}
```

运行结果：
Found at index : 6

##### 3) find_first_of() 函数

find_first_of() 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置。请看下面的代码：

```c
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1 = "first second second third";
    string s2 = "asecond";
    int index = s1.find_first_of(s2);
    if(index < s1.length())
        cout<<"Found at index : "<< index <<endl;
    else
        cout<<"Not found"<<endl;
    return 0;
}
```

运行结果：
Found at index : 3

本例中 s1 和 s2 共同具有的字符是 ’s’，该字符在 s1 中首次出现的下标是3，故查找结果返回3。

## 2.20 C++ string的内部究竟是什么样的？

在C语言中，有两种方式表示字符串：

- 一种是用字符数组来容纳字符串，例如`char str[10] = "abc"`，这样的字符串是可读写的；
- 一种是使用字符串常量，例如`char *str = "abc"`，这样的字符串只能读，不能写。


两种形式总是以`\0`作为结束标志。

C++ string 与它们在C语言中的前身截然不同。首先，也是最重要的不同点，C++ string 隐藏了它所包含的字符序列的物理表示。程序设计人员不必关心数组的维数或`\0`方面的问题。

string 在内部封装了与内存和容量有关的信息。具体地说，C++ string 对象知道自己在内存中的开始位置、包含的字符序列以及字符序列长度；当内存空间不足时，string 还会自动调整，让内存空间增长到足以容纳下所有字符序列的大小。

C++ string 的这种做法，极大地减少了C语言编程中三种最常见且最具破坏性的错误：

- 数组越界；
- 通过未被初始化或者被赋以错误值的指针来访问数组元紊；
- 释放了数组所占内存，但是仍然保留了“悬空”指针。


C++ 标准没有定义 string 类的内存布局，各个编译器厂商可以提供不同的实现，但必须保证 string 的行为一致。采用这种做法是为了获得足够的灵活性。

特別是，C++ 标准没有定义在哪种确切的情况下应该为 string 对象分配内存空间来存储字符序列。string 内存分配规则明确规定：允许但不要求以引用计数（reference counting）的方式实现。但无论是否采用引用计数，其语义都必须一致。

C++ 的这种做法和C语言不同，在C语言中，每个字符型数组都占据各自的物理存储区。在 C++ 中，独立的几个 string 对象可以占据也可以不占据各自特定的物理存储区，但是，如果采用引用计数避免了保存同一数据的拷贝副本，那么各个独立的对象（在处理上）必须看起来并表现得就像独占地拥有各自的存储区一样。例如：

```c
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1("12345");
    string s2 = s1;
    cout << (s1 == s2) << endl;
    s1[0] = '6';
    cout << "s1 = " << s1 << endl;  //62345
    cout << "s2 = " << s2 << endl;  //12345
    cout << (s1 == s2) << endl;

    return 0;
}
```

在 GCC 下的运行结果：
1
s1 = 62345
s2 = 12345
0

只有当字符串被修改的时候才创建各自的拷贝，这种实现方式称为写时复制（copy-on-write）策略。当字符串只是作为值参数（value parameter）或在其他只读情形下使用，这种方法能够节省时间和空间。

不论一个库的实现是不是采用引用计数，它对 string 类的使用者来说都应该是透明的。遗憾的是，情况并不总是这样。在多线程程序中，几乎不可能安全地使用引用计数来实现。

# 3 C++引用

## 3.1 C++引用10分钟入门教程

我们知道，参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。

对于像 char、bool、int、float 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组、结构体、对象是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率。

**C/[C++](http://c.biancheng.net/cplus/) 禁止在函数调用时直接传递数组的内容，而是强制传递数组[指针](http://c.biancheng.net/c/80/)，**这点已在《[C语言指针变量作为函数参数](http://c.biancheng.net/view/2014.html)》中进行了讲解。**而对于结构体和对象没有这种限制，调用函数时既可以传递指针，也可以直接传递内容；为了提高效率，我曾建议传递指针，这样做在大部分情况下并没有什么不妥，**读者可以点击《[C语言结构体指针](http://c.biancheng.net/view/2033.html)》进行回顾。

但是在 C++ 中，我们有了一种**比指针更加便捷的传递聚合类型数据的方式**，那就是**引用（Reference）**。

> 在 C/C++ 中，我们将 char、int、float 等由语言本身支持的类型称为基本类型，将数组、结构体、类（对象）等由基本类型组合而成的类型称为聚合类型（在讲解结构体时也曾使用复杂类型、构造类型这两种说法）。

引用（Reference）是 C++ 相对于C语言的又一个扩充。**引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据**。引用类似于 Windows 中的快捷方式，一个可执行程序可以有多个快捷方式，通过这些快捷方式和可执行程序本身都能够运行程序；引用还类似于人的绰号（笔名），使用绰号（笔名）和本名都能表示一个人。

<u>引用的定义方式类似于指针，只是用`&`取代了`*`，语法格式为</u>：

```c
type &name = data;
```

type 是被引用的数据的类型，name 是引用的名称，**<u>data 是被引用的数据。引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）</u>**。

下面是一个演示引用的实例：

```c
#include <iostream>
using namespace std;

int main() {
    int a = 99;
    int &r = a;
    cout << a << ", " << r << endl;
    cout << &a << ", " << &r << endl;

    return 0;
}
```

运行结果：
99, 99
0x28ff44, 0x28ff44

本例中，变量 r 就是变量 a 的引用，它们用来指代同一份数据；也可以说变量 r 是变量 a 的另一个名字。从输出结果可以看出，a 和 r 的地址一样，都是`0x28ff44`；或者说地址为`0x28ff44`的内存有两个名字，a 和 r，想要访问该内存上的数据时，使用哪个名字都行。

**注意，引用在定义时需要添加`&`，在使用时不能添加`&`，使用时添加`&`表示取地址。**如上面代码所示，第 6 行中的`&`表示引用，第 8 行中的`&`表示取地址。除了这两种用法，`&`还可以表示位运算中的与运算。

**由于引用 r 和原始变量 a 都是指向同一地址，所以通过引用也可以修改原始变量中所存储的数据**，请看下面的例子：

```c
#include <iostream>
using namespace std;

int main() {
    int a = 99;
    int &r = a;
    r = 47;
    cout << a << ", " << r << endl;

    return 0;
}
```

运行结果：
47, 47

最终程序输出两个 47，可见原始变量 a 的值已经被引用变量 r 所修改。

**如果读者不希望通过引用来修改原始的数据，那么可以在定义时添加 const 限制**，形式为：

```c
const type &name = value;
```

也可以是：

```c
type const &name = value;
```

这种引用方式为常引用

#### C++引用作为函数参数

**在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果**。

至于实参和形参是如何绑定的，我们将在下节《[C++引用在本质上是什么，它和指针到底有什么区别？](http://c.biancheng.net/view/vip_2252.html)》中讲解，届时我们会一针见血地阐明引用的本质。

一个能够展现按引用传参的优势的例子就是交换两个数的值，请看下面的代码：

```c
#include <iostream>
using namespace std;

void swap1(int a, int b);
void swap2(int *p1, int *p2);
void swap3(int &r1, int &r2);


int main() {
    int num1, num2;
    cout << "Input two integers: ";
    cin >> num1 >> num2;
    swap1(num1, num2);
    cout << num1 << " " << num2 << endl;

    cout << "Input two integers: ";
    cin >> num1 >> num2;
    swap2(&num1, &num2);
    cout << num1 << " " << num2 << endl;

    cout << "Input two integers: ";
    cin >> num1 >> num2;
    swap3(num1, num2);
    cout << num1 << " " << num2 << endl;

    return 0;
}

//直接传递参数内容
void swap1(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

//传递指针
void swap2(int *p1, int *p2) {
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

//按引用传参
void swap3(int &r1, int &r2) {
    int temp = r1;
    r1 = r2;
    r2 = temp;
}
```

运行结果：
Input two integers: 12 34↙
12 34
Input two integers: 88 99↙
99 88
Input two integers: 100 200↙
200 100

从以上代码的编写中可以发现，按**引用传参在使用形式上比指针更加直观**。在以后的 C++ 编程中，我鼓励读者大量使用引用，它一般可以代替指针（当然指针在C++中也不可或缺），C++ 标准库也是这样做的。

#### C++引用作为函数返回值

引用除了可以作为函数形参，还可以作为函数返回值，请看下面的例子：

```c
#include <iostream>
using namespace std;

int &plus10(int &r) {
    r += 10;
    return r;
}

int main() {
    int num1 = 10;
    int num2 = plus10(num1);
    cout << num1 << " " << num2 << endl;

    return 0;
}
```

运行结果：
20 20

**<u>在将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用</u>，因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告。**

更改上面的例子，让 plus10() 返回一个局部数据的引用：

```c
#include <iostream>
using namespace std;

int &plus10(int &r) {
    int m = r + 10;
    return m;  //返回局部数据的引用
}

int main() {
    int num1 = 10;
    int num2 = plus10(num1);
    cout << num2 << endl;
    int &num3 = plus10(num1);
    int &num4 = plus10(num3);
    cout << num3 << " " << num4 << endl;

    return 0;
}
```

在 Visual Studio 下的运行结果：

20
-858993450 -858993450

在 [GCC](http://c.biancheng.net/gcc/) 下的运行结果：

20
30 30

在 C-Free 下的运行结果：

20
30 0

而我们期望的运行结果是：

20
20 30

plus10() 返回一个对局部变量 m 的引用，这是导致运行结果非常怪异的根源，因为函数是在栈上运行的，并且运行结束后会放弃对所有局部数据的管理权，后面的函数调用会覆盖前面函数的局部数据。本例中，第二次调用 plus10() 会覆盖第一次调用 plus10() 所产生的局部数据，第三次调用 plus10() 会覆盖第二次调用 plus10() 所产生的局部数据。

关于函数调用的内部实现，我已在《[C语言内存精讲](http://c.biancheng.net/c/140/)》专题中讲到。

## 3.2 C++引用在本质上是什么，它和指针到底有什么区别？

### 引用和指针的其他区别

\1) 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。

\2) 可以有 const 指针，但是没有 const 引用。也就是说，引用变量不能定义为下面的形式：

```
int a = 20;int & const r = a;
```

因为 r 本来就不能改变指向，加上 const 是多此一举。

\3) 指针可以有多级，但是引用只能有一级，例如，`int **p`是合法的，而`int &&r`是不合法的。如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个`&`，如下所示：

```
int a = 10;int &r = a;int &rr = r;
```


\4) 指针和引用的自增（++）自减（--）运算意义不一样。对指针使用 ++ 表示指向下一份数据，**对引用使用 ++ 表示它所指代的数据本身加 1**；自减（--）也是类似的道理。请看下面的例子：

```c
#include <iostream>
using namespace std;

int main (){
    int a = 10;
    int &r = a;
    r++;
    cout<<r<<endl;
   
    int arr[2] = { 27, 84 };
    int *p = arr;
    p++;
    cout<<*p<<endl;

    return 0;
}
```

运行结果：
11
84

## 3.3 C++引用不能绑定到临时数据

我们知道，指针就是数据或代码在内存中的地址，指针变量指向的就是内存中的数据或代码。这里有一个关键词需要强调，就是`内存`，指针只能指向内存，不能指向寄存器或者硬盘，因为寄存器和硬盘没法寻址。

其实 C++ 代码中的大部分内容都是放在内存中的，例如定义的变量、创建的对象、字符串常量、函数形参、函数体本身、`new`或`malloc()`分配的内存等，这些内容都可以用`&`来获取地址，进而用指针指向它们。除此之外，还有一些我们平时不太留意的临时数据，例如表达式的结果、函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中。一旦它们被放到了寄存器中，就没法用`&`获取它们的地址了，也就没法用指针指向它们了。

下面的代码演示了表达式所产生的临时结果：

```c
int n = 100, m = 200;
int *p1 = &(m + n);    //m + n 的结果为 300
int *p2 = &(n + 100);  //n + 100 的结果为 200
bool *p4 = &(m < n);   //m < n 的结果为 false
```

这些表达式的结果都会被放到寄存器中，尝试用`&`获取它们的地址都是错误的。

下面的代码演示了函数返回值所产生的临时结果：

```c
int func(){
    int n = 100;
    return n;
}

int *p = &(func());
```

func() 的返回值 100 也会被放到寄存器中，也没法用`&`获取它的地址。

### 什么样的临时数据会放到寄存器中

寄存器离 CPU 近，并且速度比内存快，将临时数据放到寄存器是为了加快程序运行。但是寄存器的数量是非常有限的，容纳不下较大的数据，所以只能将较小的临时数据放在寄存器中。int、double、bool、char 等基本类型的数据往往不超过 8 个字节，用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；而对象、结构体变量是自定义类型的数据，大小不可预测，所以这些类型的临时数据通常会放到内存中。

下面的代码是正确的，它证明了结构体类型的临时数据会被放到内存中：

```c
#include <iostream>
using namespace std;

typedef struct{
    int a;
    int b;
} S;

//这里用到了一点新知识，叫做运算符重载，我们会在《运算符重载》一章中详细讲解
S operator+(const S &A, const S &B){
    S C;
    C.a = A.a + B.a;
    C.b = A.b + B.b;
    return C;
}

S func(){
    S a;
    a.a = 100;
    a.b = 200;
    return a;
}

int main(){
    S s1 = {23, 45};
    S s2 = {90, 75};
    S *p1 = &(s1 + s2);
    S *p2 = &(func());
    cout<<p1<<", "<<p2<<endl;

    return 0;
}
```

运行结果：
0x28ff28, 0x28ff18

> 第10行代码用到了运算符重载，我们将在《[C++运算符重载](http://c.biancheng.net/cpp/biancheng/cpp/rumen_10/)》一章中详细讲解。

### 关于常量表达式

诸如 100、200+34、34.5*23、3+7/3 等不包含变量的表达式称为常量表达式（Constant expression）。

常量表达式由于不包含变量，没有不稳定因素，所以在编译阶段就能求值。编译器不会分配单独的内存来存储常量表达式的值，而是将常量表达式的值和代码合并到一起，放到虚拟地址空间中的代码区。从汇编的角度看，常量表达式的值就是一个立即数，会被“硬编码”到指令中，不能寻址。

> 关于虚拟地址空间的分区，我们已在《[Linux下C语言程序的内存布局](http://c.biancheng.net/view/vip_2097.html)》一节中讲到。

总起来说，常量表达式的值虽然在内存中，但是没有办法寻址，所以也不能使用`&`来获取它的地址，更不能用指针指向它。下面的代码是错误的，它证明了不能用`&`来获取常量表达式的地址：

```c
int *p1 = &(100);
int *p2 = &(23 + 45 * 2);
```

### 引用也不能指代临时数据

引用和指针在本质上是一样的，引用仅仅是对指针进行了简单的封装。引用和指针都不能绑定到无法寻址的临时数据，并且 C++ 对引用的要求更加严格，在某些编译器下甚至连放在内存中的临时数据都不能指代。

下面的代码中，我们将引用绑定到了临时数据：

```c
typedef struct{
    int a;
    int b;
} S;

int func_int(){
    int n = 100;
    return n;
}

S func_s(){
    S a;
    a.a = 100;
    a.b = 200;
    return a;
}

//这里用到了一点新知识，叫做运算符重载，我们会在《运算符重载》一章中详细讲解
S operator+(const S &A, const S &B){
    S C;
    C.a = A.a + B.a;
    C.b = A.b + B.b;
    return C;
}

int main(){
    //下面的代码在GCC和Visual C++下都是错误的
    int m = 100, n = 36;
    int &r1 = m + n;
    int &r2 = m + 28;
    int &r3 = 12 * 3;
    int &r4 = 50;
    int &r5 = func_int();
   
    //下面的代码在GCC下是错误的，在Visual C++下是正确的
    S s1 = {23, 45};
    S s2 = {90, 75};
    S &r6 = func_s();
    S &r7 = s1 + s2;

    return 0;
}
```

第 28~33 行代码在 GCC 和 Visual C++ 下都不能编译通过，第 38~39 行代码在 Visual C++ 下能够编译通过，但是在 GCC 下编译失败。这说明：

- 在 GCC 下，引用不能指代任何临时数据，不管它保存到哪里；
- 在 Visual C++ 下，引用只能指代位于内存中（非代码区）的临时数据，不能指代寄存器中的临时数据。

### 引用作为函数参数

当引用作为函数参数时，有时候很容易给它传递临时数据。下面的 isOdd() 函数用来判断一个数是否是奇数：

```c
bool isOdd(int &n){
    if(n%2 == 0){
        return false;
    }else{
        return true;
    }
}

int main(){
    int a = 100;
    isOdd(a);  //正确
    isOdd(a + 9);  //错误
    isOdd(27);  //错误
    isOdd(23 + 55);  //错误

    return 0;
}
```

isOdd() 函数用来判断一个数是否为奇数，它的参数是引用类型，只能传递变量，不能传递常量或者表达式。但用来判断奇数的函数不能接受一个数字又让人感觉很奇怪，所以类似这样的函数应该坚持使用值传递，而不是引用传递。

下面是更改后的代码：

```c
bool isOdd(int n){  //改为值传递
    if(n%2 == 0){
        return false;
    }else{
        return true;
    }
}

int main(){
    int a = 100;
    isOdd(a);  //正确
    isOdd(a + 9);  //正确
    isOdd(27);  //正确
    isOdd(23 + 55);  //正确

    return 0;
}
```

## 3.4 编译器会为const引用创建临时变量

上节我们讲到，引用不能绑定到临时数据，这在大多数情况下是正确的，但是当使用 const 关键字对引用加以限定后，引用就可以绑定到临时数据了。下面的代码演示了引用和 const 这一对神奇的组合：

```c
typedef struct{
    int a;
    int b;
} S;

int func_int(){
    int n = 100;
    return n;
}

S func_s(){
    S a;
    a.a = 100;
    a.b = 200;
    return a;
}

S operator+(const S &A, const S &B){
    S C;
    C.a = A.a + B.a;
    C.b = A.b + B.b;
    return C;
}

int main(){
    int m = 100, n = 36;
    const int &r1 = m + n;
    const int &r2 = m + 28;
    const int &r3 = 12 * 3;
    const int &r4 = 50;
    const int &r5 = func_int();

    S s1 = {23, 45};
    S s2 = {90, 75};
    const S &r6 = func_s();
    const S &r7 = s1 + s2;

    return 0;
}
```

这段代码在 GCC 和 Visual C++ 下都能够编译通过，这是因为将常引用绑定到临时数据时，编译器采取了一种妥协机制：编译器会为临时数据创建一个新的、无名的临时变量，并将临时数据放入该临时变量中，然后再将引用绑定到该临时变量。注意，临时变量也是变量，所有的变量都会被分配内存。

为什么编译器为常引用创建临时变量是合理的，而为普通引用创建临时变量就不合理呢？

\1) 我们知道，将引用绑定到一份数据后，就可以通过引用对这份数据进行操作了，包括读取和写入（修改）；尤其是写入操作，会改变数据的值。而临时数据往往无法寻址，是不能写入的，即使为临时数据创建了一个临时变量，那么修改的也仅仅是临时变量里面的数据，不会影响原来的数据，这样就使得引用所绑定到的数据和原来的数据不能同步更新，最终产生了两份不同的数据，失去了引用的意义。

以《[C++引用10分钟入门教程](http://c.biancheng.net/view/2251.html)》一节中讲到的 swap() 函数为例：

```c
void swap(int &r1, int &r2){
    int temp = r1;
    r1 = r2;
    r2 = temp;
}
```

如果编译器会为 r1、r2 创建临时变量，那么函数调用`swap(10, 20)`就是正确的，但是 10 不会变成 20，20 也不会变成 10，所以这种调用是毫无意义的。

总起来说，不管是从“引用的语义”这个角度看，还是从“实际应用的效果”这个角度看，为普通引用创建临时变量都没有任何意义，所以编译器不会这么做。

\2) const 引用和普通引用不一样，我们只能通过 const 引用读取数据的值，而不能修改它的值，所以不用考虑同步更新的问题，也不会产生两份不同的数据，为 const 引用创建临时变量反而会使得引用更加灵活和通用。

以上节的 isOdd() 函数为例：

```c
bool isOdd(const int &n){  //改为常引用
    if(n/2 == 0){
        return false;
    }else{
        return true;
    }
}
```

由于在函数体中不会修改 n 的值，所以可以用 const 限制 n，这样一来，下面的函数调用就都是正确的了：

```c
int a = 100;
isOdd(a);  //正确
isOdd(a + 9);  //正确
isOdd(27);  //正确
isOdd(23 + 55);  //正确
```

对于第 2 行代码，编译器不会创建临时变量，会直接绑定到变量 a；对于第 3~5 行代码，编译器会创建临时变量来存储临时数据。也就是说，编译器只有在必要时才会创建临时变量。

## 3.5 C++ const引用与转换类型

### const 引用与类型转换

「类型严格一致」是为了防止发生让人匪夷所思的操作，但是这条规则仅仅适用于普通引用，当对引用添加 const 限定后，情况就又发生了变化，编译器允许引用绑定到类型不一致的数据。请看下面的代码：

```c
int n = 100;
int &r1 = n;  //正确
const float &r2 = n;  //正确

char c = '@';
char &r3 = c;  //正确
const int &r4 = c;  //正确 
```

当引用的类型和数据的类型不一致时，如果它们的类型是相近的，并且遵守「数据类型的自动转换」规则，那么编译器就会创建一个临时变量，并将数据赋值给这个临时变量（这时候会发生自动类型转换），然后再将引用绑定到这个临时的变量，这与「将 const 引用绑定到临时数据时」采用的方案是一样的。

注意，临时变量的类型和引用的类型是一样的，在将数据赋值给临时变量时会发生自动类型转换。请看下面的代码：

```c
float f = 12.45;const int &r = f;printf("%d", r);
```

该代码的输出结果为 12，说明临时变量和引用的类型都是 int（严格来说引用的类型是 int &），并没有变为 float。

当引用的类型和数据的类型不遵守「数据类型的自动转换」规则，那么编译器将报错，绑定失败，例如：

```c
char *str = "http://c.biancheng.net";const int &r = str;
```

`char *`和`int`两种类型没有关系，不能自动转换，这种引用就是错误的。

结合上节讲到的知识，总结起来说，给引用添加 const 限定后，不但可以将引用绑定到临时数据，还可以将引用绑定到类型相近的数据，这使得引用更加灵活和通用，它们背后的机制都是临时变量。

### 引用类型的函数形参请尽可能的使用 const

当引用作为函数参数时，如果在函数体内部不会修改引用所绑定的数据，那么请尽量为该引用添加 const 限制。

下面的例子演示了 const 引用的灵活性：

```c
#include <cstdio>
using namespace std;

double volume(const double &len, const double &width, const double &hei){
    return len*width*2 + len*hei*2 + width*hei*2;
}

int main(){
    int a = 12, b = 3, c = 20;
    double v1 = volume(a, b, c);
    double v2 = volume(10, 20, 30);
    double v3 = volume(89.4, 32.7, 19);
    double v4 = volume(a+12.5, b+23.4, 16.78);
    double v5 = volume(a+b, a+c, b+c);
    printf("%lf, %lf, %lf, %lf, %lf\n", v1, v2, v3, v4, v5);

    return 0;
}
```

运行结果：
672.000000, 2200.000000, 10486.560000, 3001.804000, 3122.000000

volume() 函数用来求一个长方体的体积，它可以接收不同类型的实参，也可以接收常量或者表达式。

概括起来说，将引用类型的形参添加 const 限制的理由有三个：

- **使用 const 可以避免无意中修改数据的编程错误；**
- **使用 const 能让函数接收 const 和非 const 类型的实参，否则将只能接收非 const 类型的实参；**
- **使用 const 引用能够让函数正确生成并使用临时变量。**

# 4 C++继承与派生

## 4.2 C++三种继承方式

### public、protected、private 修饰类的成员

protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用.

### public、protected、private 指定继承方式

不同的继承方式会影响基类成员在派生类中的访问权限。

#### **1) public继承方式**

- 基类中所有 public 成员在派生类中为 public 属性；
- 基类中所有 protected 成员在派生类中为 protected 属性；
- 基类中所有 private 成员在派生类中不能使用。



#### **2) protected继承方式**

- 基类中的所有 public 成员在派生类中为 protected 属性；
- 基类中的所有 protected 成员在派生类中为 protected 属性；
- 基类中的所有 private 成员在派生类中不能使用。



#### **3) private继承方式**

- 基类中的所有 public 成员在派生类中均为 private 属性；
- 基类中的所有 protected 成员在派生类中均为 private 属性；
- 基类中的所有 private 成员在派生类中不能使用。


通过上面的分析可以发现：
\1) 基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为 protected 时，那么基类成员在派生类中的访问权限最高也为 protected，高于 protected 的会降级为 protected，但低于 protected 不会升级。再如，当继承方式为 public 时，那么基类成员在派生类中的访问权限将保持不变。

也就是说，继承方式中的 public、protected、private 是用来指明基类成员在派生类中的最高访问权限的。

\2) 不管继承方式如何，基类中的 private 成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。

\3) 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为 public 或 protected；只有那些不希望在派生类中使用的成员才声明为 private。

\4) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。

注意，我们这里说的是基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。



| 继承方式/基类成员 | public成员 | protected成员 | private成员 |
| ----------------- | ---------- | ------------- | ----------- |
| public继承        | public     | protected     | 不可见      |
| protected继承     | protected  | protected     | 不可见      |
| private继承       | private    | private       | 不可见      |


由于 private 和 protected 继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以实际开发中我们一般使用 public。

【示例】演示类的继承关系。

```
#include<iostream>using namespace std;//基类Peopleclass People{public:    void setname(char *name);    void setage(int age);    void sethobby(char *hobby);    char *gethobby();protected:    char *m_name;    int m_age;private:    char *m_hobby;};void People::setname(char *name){ m_name = name; }void People::setage(int age){ m_age = age; }void People::sethobby(char *hobby){ m_hobby = hobby; }char *People::gethobby(){ return m_hobby; }//派生类Studentclass Student: public People{public:    void setscore(float score);protected:    float m_score;};void Student::setscore(float score){ m_score = score; }//派生类Pupilclass Pupil: public Student{public:    void setranking(int ranking);    void display();private:    int m_ranking;};void Pupil::setranking(int ranking){ m_ranking = ranking; }void Pupil::display(){    cout<<m_name<<"的年龄是"<<m_age<<"，考试成绩为"<<m_score<<"分，班级排名第"<<m_ranking<<"，TA喜欢"<<gethobby()<<"。"<<endl;}int main(){    Pupil pup;    pup.setname("小明");    pup.setage(15);    pup.setscore(92.5f);    pup.setranking(4);    pup.sethobby("乒乓球");    pup.display();    return 0;}
```

运行结果：
小明的年龄是15，考试成绩为92.5分，班级排名第4，TA喜欢乒乓球。

这是一个多级继承的例子，Student 继承自 People，Pupil 又继承自 Student，它们的继承关系为 People --> Student --> Pupil。Pupil 是最终的派生类，它拥有基类的 m_name、m_age、m_score、m_hobby 成员变量以及 setname()、setage()、sethobby()、gethobby()、setscore() 成员函数。

注意，在派生类 Pupil 的成员函数 display() 中，我们借助基类的 public 成员函数 gethobby() 来访问基类的 private 成员变量 m_hobby，因为 m_hobby 是 private 属性的，在派生类中不可见，所以只能借助基类的 public 成员函数 sethobby()、gethobby() 来访问。

在派生类中访问基类 private 成员的唯一方法就是借助基类的非 private 成员函数，如果基类没有非 private 成员函数，那么该成员在派生类中将无法访问。

### 改变访问权限

使用 using 关键字可以改变基类成员在派生类中的访问权限，例如将 public 改为 private、将 protected 改为 public。

注意：using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限，因为基类中 private 成员在派生类中是不可见的，根本不能使用，所以基类中的 private 成员在派生类中无论如何都不能访问。

using 关键字使用示例：

```c
#include<iostream>
using namespace std;

//基类People
class People {
public:
    void show();
protected:
    char *m_name;
    int m_age;
};
void People::show() {
    cout << m_name << "的年龄是" << m_age << endl;
}

//派生类Student
class Student : public People {
public:
    void learning();
public:
    using People::m_name;  //将protected改为public
    using People::m_age;  //将protected改为public
    float m_score;
private:
    using People::show;  //将public改为private
};
void Student::learning() {
    cout << "我是" << m_name << "，今年" << m_age << "岁，这次考了" << m_score << "分！" << endl;
}

int main() {
    Student stu;
    stu.m_name = "小明";
    stu.m_age = 16;
    stu.m_score = 99.5f;
    stu.show();  //compile error
    stu.learning();

    return 0;
}
```

代码中首先定义了基类 People，它包含两个 protected 属性的成员变量和一个 public 属性的成员函数。定义 Student 类时采用 public 继承方式，People 类中的成员在 Student 类中的访问权限默认是不变的。

不过，我们使用 using 改变了它们的默认访问权限，如代码第 21~25 行所示，将 show() 函数修改为 private 属性的，是降低访问权限，将 name、age 变量修改为 public 属性的，是提高访问权限。

因为 show() 函数是 private 属性的，所以代码第 36 行会报错。把该行注释掉，程序输出结果为：
我是小明，今年16岁，这次考了99.5分！

## 4.3 C++继承时的名字遮蔽问题

如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。

下面是一个成员函数的名字遮蔽的例子：

```c
#include<iostream>
using namespace std;

//基类People
class People{
public:
    void show();
protected:
    char *m_name;
    int m_age;
};
void People::show(){
    cout<<"嗨，大家好，我叫"<<m_name<<"，今年"<<m_age<<"岁"<<endl;
}

//派生类Student
class Student: public People{
public:
    Student(char *name, int age, float score);
public:
    void show();  //遮蔽基类的show()
private:
    float m_score;
};
Student::Student(char *name, int age, float score){
    m_name = name;
    m_age = age;
    m_score = score;
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

int main(){
    Student stu("小明", 16, 90.5);
    //使用的是派生类新增的成员函数，而不是从基类继承的
    stu.show();
    //使用的是从基类继承来的成员函数
    stu.People::show();

    return 0;
}
```

运行结果：
小明的年龄是16，成绩是90.5
嗨，大家好，我叫小明，今年16岁

本例中，基类 People 和派生类 Student 都定义了成员函数 show()，它们的名字一样，会造成遮蔽。第 37 行代码中，stu 是 Student 类的对象，默认使用 Student 类的 show() 函数。

但是，基类 People 中的 show() 函数仍然可以访问，不过要加上类名和域解析符，如第 39 行代码所示。

## 基类成员函数和派生类成员函数不构成重载

基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。

## 4.14 C++将派生类赋值给基类（向上转型）

类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类[指针](http://c.biancheng.net/c/80/)赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。

向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。

将派生类对象赋值给基类对象时，会舍弃派生类新增的成员，也就是“大材小用”，如下图所示：

![img](http://c.biancheng.net/uploads/allimg/190214/1G45K0C-0.png)


可以发现，即使将派生类对象赋值给基类对象，基类对象也不会包含派生类的成员

这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值。理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。

### 将派生类指针赋值给基类指针









# 6 C++运算符重载（operator）

## 6.1 C++运算符重载基础教程

```c
#include <iostream>
using namespace std;

class complex{
public:
    complex();
    complex(double real, double imag);
public:
    //声明运算符重载
    complex operator+(const complex &A) const;
    void display() const;
private:
    double m_real;  //实部
    double m_imag;  //虚部
};

complex::complex(): m_real(0.0), m_imag(0.0){ }
complex::complex(double real, double imag): m_real(real), m_imag(imag){ }

//实现运算符重载
complex complex::operator+(const complex &A) const{
    complex B;
    B.m_real = this->m_real + A.m_real;
    B.m_imag = this->m_imag + A.m_imag;
    return B;
}

void complex::display() const{
    cout<<m_real<<" + "<<m_imag<<"i"<<endl;
}

int main(){
    complex c1(4.3, 5.8);
    complex c2(2.4, 3.7);
    complex c3;
    c3 = c1 + c2;
    c3.display();
 
    return 0;
}
```

运算符重载的格式为：

```c
返回值类型 operator 运算符名称 (形参表列){
  //TODO:
}
c3 = c1.operator+(c2);
```

`operator`是关键字，专门用于定义重载运算符的函数。我们可以将`operator 运算符名称`这一部分看做函数名，对于上面的代码，函数名就是`operator+`。

### 在全局范围内重载运算符

```c
#include <iostream>
using namespace std;

class complex{
public:
    complex();
    complex(double real, double imag);
public:
    void display() const;
    //声明为友元函数
    friend complex operator+(const complex &A, const complex &B);
private:
    double m_real;
    double m_imag;
};

complex operator+(const complex &A, const complex &B);

complex::complex(): m_real(0.0), m_imag(0.0){ }
complex::complex(double real, double imag): m_real(real), m_imag(imag){ }
void complex::display() const{
    cout<<m_real<<" + "<<m_imag<<"i"<<endl;
}

//在全局范围内重载+
complex operator+(const complex &A, const complex &B){
    complex C;
    C.m_real = A.m_real + B.m_real;
    C.m_imag = A.m_imag + B.m_imag;
    return C;
}

int main(){
    complex c1(4.3, 5.8);
    complex c2(2.4, 3.7);
    complex c3;
    c3 = c1 + c2;
    c3.display();
 
    return 0;
}
```

运算符重载函数不是 complex 类的成员函数，但是却用到了 complex 类的 private 成员变量，所以必须在 complex 类中将该函数声明为友元函数。

## 6.2 C++运算符重载时要遵循的规则

\1) 并不是所有的运算符都可以重载。能够重载的运算符包括：
\+ - * / % ^ & | ~ ! = < > += -= *= /= %= ^= &= |=  << >> <<= >>= == != <= >= && || ++ -- , ->* -> () []  new new[] delete delete[]

上述运算符中，`[]`是下标运算符，`()`是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符`sizeof`、条件运算符`: ?`、成员选择符`.`和域解析运算符`::`不能被重载。

\2) 重载不能改变运算符的优先级和结合性。

\3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。例如`~`号右边只有一个操作数，`+`号总是出现在两个操作数之间，重载后也必须如此。

\4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。

\5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。

将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。

\6) 箭头运算符`->`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符`=`只能以成员函数的形式重载。

## 6.3 C++重载数学运算符（实例演示）

```c
#include <iostream>
#include <cmath>
using namespace std;

//复数类
class Complex{
public:  //构造函数
    Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }
public:  //运算符重载
    //以全局函数的形式重载
    friend Complex operator+(const Complex &c1, const Complex &c2);
    friend Complex operator-(const Complex &c1, const Complex &c2);
    friend Complex operator*(const Complex &c1, const Complex &c2);
    friend Complex operator/(const Complex &c1, const Complex &c2);
    friend bool operator==(const Complex &c1, const Complex &c2);
    friend bool operator!=(const Complex &c1, const Complex &c2);
    //以成员函数的形式重载
    Complex & operator+=(const Complex &c);
    Complex & operator-=(const Complex &c);
    Complex & operator*=(const Complex &c);
    Complex & operator/=(const Complex &c);
public:  //成员函数
    double real() const{ return m_real; }
    double imag() const{ return m_imag; }
private:
    double m_real;  //实部
    double m_imag;  //虚部
};

//重载+运算符
Complex operator+(const Complex &c1, const Complex &c2){
    Complex c;
    c.m_real = c1.m_real + c2.m_real;
    c.m_imag = c1.m_imag + c2.m_imag;
    return c;
}
//重载-运算符
Complex operator-(const Complex &c1, const Complex &c2){
    Complex c;
    c.m_real = c1.m_real - c2.m_real;
    c.m_imag = c1.m_imag - c2.m_imag;
    return c;
}
//重载*运算符  (a+bi) * (c+di) = (ac-bd) + (bc+ad)i
Complex operator*(const Complex &c1, const Complex &c2){
    Complex c;
    c.m_real = c1.m_real * c2.m_real - c1.m_imag * c2.m_imag;
    c.m_imag = c1.m_imag * c2.m_real + c1.m_real * c2.m_imag;
    return c;
}
//重载/运算符  (a+bi) / (c+di) = [(ac+bd) / (c²+d²)] + [(bc-ad) / (c²+d²)]i
Complex operator/(const Complex &c1, const Complex &c2){
    Complex c;
    c.m_real = (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) / (pow(c2.m_real, 2) + pow(c2.m_imag, 2));
    c.m_imag = (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) / (pow(c2.m_real, 2) + pow(c2.m_imag, 2));
    return c;
}
//重载==运算符
bool operator==(const Complex &c1, const Complex &c2){
    if( c1.m_real == c2.m_real && c1.m_imag == c2.m_imag ){
        return true;
    }else{
        return false;
    }
}
//重载!=运算符
bool operator!=(const Complex &c1, const Complex &c2){
    if( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag ){
        return true;
    }else{
        return false;
    }
}

//重载+=运算符
Complex & Complex::operator+=(const Complex &c){
    this->m_real += c.m_real;
    this->m_imag += c.m_imag;
    return *this;
}
//重载-=运算符
Complex & Complex::operator-=(const Complex &c){
    this->m_real -= c.m_real;
    this->m_imag -= c.m_imag;
    return *this;
}
//重载*=运算符
Complex & Complex::operator*=(const Complex &c){
    this->m_real = this->m_real * c.m_real - this->m_imag * c.m_imag;
    this->m_imag = this->m_imag * c.m_real + this->m_real * c.m_imag;
    return *this;
}
//重载/=运算符
Complex & Complex::operator/=(const Complex &c){
    this->m_real = (this->m_real*c.m_real + this->m_imag*c.m_imag) / (pow(c.m_real, 2) + pow(c.m_imag, 2));
    this->m_imag = (this->m_imag*c.m_real - this->m_real*c.m_imag) / (pow(c.m_real, 2) + pow(c.m_imag, 2));
    return *this;
}

int main(){
    Complex c1(25, 35);
    Complex c2(10, 20);
    Complex c3(1, 2);
    Complex c4(4, 9);
    Complex c5(34, 6);
    Complex c6(80, 90);
   
    Complex c7 = c1 + c2;
    Complex c8 = c1 - c2;
    Complex c9 = c1 * c2;
    Complex c10 = c1 / c2;
    cout<<"c7 = "<<c7.real()<<" + "<<c7.imag()<<"i"<<endl;
    cout<<"c8 = "<<c8.real()<<" + "<<c8.imag()<<"i"<<endl;
    cout<<"c9 = "<<c9.real()<<" + "<<c9.imag()<<"i"<<endl;
    cout<<"c10 = "<<c10.real()<<" + "<<c10.imag()<<"i"<<endl;
   
    c3 += c1;
    c4 -= c2;
    c5 *= c2;
    c6 /= c2;
    cout<<"c3 = "<<c3.real()<<" + "<<c3.imag()<<"i"<<endl;
    cout<<"c4 = "<<c4.real()<<" + "<<c4.imag()<<"i"<<endl;
    cout<<"c5 = "<<c5.real()<<" + "<<c5.imag()<<"i"<<endl;
    cout<<"c6 = "<<c6.real()<<" + "<<c6.imag()<<"i"<<endl;
   
    if(c1 == c2){
        cout<<"c1 == c2"<<endl;
    }
    if(c1 != c2){
        cout<<"c1 != c2"<<endl;
    }
   
    return 0;
}
```

## 6.4 到底以成员函数还是全局函数（友元函数）的形式重载运算符

### 简单地了解转换构造函数

在分析以前，我们先来了解一个概念，叫做「转换构造函数」。这个概念将会在《[C++转换构造函数](http://c.biancheng.net/cpp/biancheng/view/3291.html)》一节中深入讲解，但是为了搞清成员函数和全局函数的区别，本节我们有必要提前了解一下。

请大家先看下面的例子：

```c++
#include <iostream>
using namespace std;

//复数类
class Complex{
public:
    Complex(): m_real(0.0), m_imag(0.0){ }
    Complex(double real, double imag): m_real(real), m_imag(imag){ }
    Complex(double real): m_real(real), m_imag(0.0){ }  //转换构造函数
public:
    friend Complex operator+(const Complex &c1, const Complex &c2);
public:
    double real() const{ return m_real; }
    double imag() const{ return m_imag; }
private:
    double m_real;  //实部
    double m_imag;  //虚部
};

//重载+运算符
Complex operator+(const Complex &c1, const Complex &c2){
    Complex c;
    c.m_real = c1.m_real + c2.m_real;
    c.m_imag = c1.m_imag + c2.m_imag;
    return c;
}

int main(){
    Complex c1(25, 35);
    Complex c2 = c1 + 15.6;
    Complex c3 = 28.23 + c1;
    cout<<c2.real()<<" + "<<c2.imag()<<"i"<<endl;
    cout<<c3.real()<<" + "<<c3.imag()<<"i"<<endl;
   
    return 0;
}
```

运行结果：
40.6 + 35i
53.23 + 35i

请读者留意第 30、31 行代码，它说明 Complex 类型可以和 double 类型相加，这很奇怪，因为我们并没有对针对这两个类型重载 +，这究竟是怎么做到的呢？

其实，编译器在检测到 Complex 和 double（小数默认为 double 类型）相加时，会先尝试将 double 转换为 Complex，或者反过来将 Complex 转换为 double（只有类型相同的数据才能进行 + 运算），如果都转换失败，或者都转换成功（产生了二义性），才报错。本例中，编译器会先通过构造函数`Complex(double real);`将 double 转换为 Complex，再调用重载过的 + 进行计算，整个过程类似于下面的形式：
![img](http://c.biancheng.net/uploads/allimg/190215/153025ET-0.png)
也就是说，小数被转换成了匿名的 Complex 对象。在这个转换过程中，构造函数`Complex(double real);`起到了至关重要的作用，如果没有它，转换就会失败，Complex 也不能和 double 相加。

`Complex(double real);`在作为普通构造函数的同时，还能将 double 类型转换为 Complex 类型，集合了“构造函数”和“类型转换”的功能，所以被称为「转换构造函数」。换句话说，转换构造函数用来将其它类型（可以是 bool、int、double 等基本类型，也可以是数组、指针、结构体、类等构造类型）转换为当前类类型。

作为了解，这里不再对转换构造函数阐述更多细节，后续将在《[C++转换构造函数](http://c.biancheng.net/cpp/biancheng/view/3291.html)》一节中深入讲解。

### 为什么要以全局函数的形式重载 +

上面的例子中，我们定义的`operator+`是一个全局函数（一个友元函数），而不是成员函数，这样做是为了保证 + 运算符的操作数能够被对称的处理；换句话说，小数（double 类型）在 + 左边和右边都是正确的。第 30 行代码中，15.6 在 + 的右边，第 31 行代码中，28.23 在 + 的左边，它们都能够被顺利地转换为 Complex 类型，所以不会出错。

如果将`operator+`定义为成员函数，根据“+ 运算符具有左结合性”这条原则，`Complex c2 = c1 + 15.6;`会被转换为下面的形式：

Complex c2 = c1.operator+(Complex(15.6));

这就是通过对象调用成员函数，是正确的。而对于`Complex c3 = 28.23 + c1;`，编译器会尝试转换为不同的形式：

Complex c3 = (28.23).operator+(c1);

很显然这是错误的，因为 double 类型并没有以成员函数的形式重载 +。

也就是说，以成员函数的形式重载 +，只能计算`c1 + 15.6`，不能计算`28.23 + c1`，这是不对称的

有读者可能会问，编译器明明可以把 28.23 先转换成 Complex 类型再相加呀，也就是下面的形式：

Complex c3 = Complex(28.23).operator+(c1);

为什么就是不转换呢？没错，编译器不会转换，原因在于，C++ 只会对成员函数的参数进行类型转换，而不会对调用成员函数的对象进行类型转换。以下面的语句为例：

obj.func(params);

编译器不会尝试对 obj 进行任何类型转换，它有 func() 成员函数就调用，没有就报错。而对于实参 params，编译器会“拼命地”将它转换为形参的类型。

### 为什么要以成员函数的形式重载 +=

我们首先要明白，运算符重载的初衷是给类添加新的功能，方便类的运算，它作为类的成员函数是理所应当的，是首选的。不过，类的成员函数不能对称地处理数据，程序员必须在（参与运算的）所有类型的内部都重载当前的运算符。以上面的情况为例，我们必须在 Complex 和 double 内部都重载 + 运算符，这样做不但会增加运算符重载的数目，还要在许多地方修改代码，这显然不是我们所希望的，所以 C++ 进行了折中，允许以全局函数（友元函数）的形式重载运算符。

C++ 创始人 Bjarne Stroustrup 也曾考虑过为内部类型（bool、int、double 等）定义额外运算符的问题，但后来还是放弃了这种想法，因为 Bjarne Stroustrup 不希望改变现有规则：任何类型（无论是内部类型还是用户自定义类型）都不能在其定义完成以后再增加额外的操作。这里还有另外的一个原因，C内部类型之间的转换已经够肮脏了，决不能再向里面添乱。而通过成员函数为已存在的类型提供混合运算的方式，从本质上看，比我们所采用的全局函数（友元函数）加转换构造函数的方式还要肮脏许多。

采用全局函数能使我们定义这样的运算符，它们的参数具有逻辑的对称性。与此相对应的，把运算符定义为成员函数能够保证在调用时对第一个（最左的）运算对象不出现类型转换，也就是上面提到的「C++ 不会对调用成员函数的对象进行类型转换」。

总起来说，有一部分运算符重载既可以是成员函数也可以是全局函数，虽然没有一个必然的、不可抗拒的理由选择成员函数，但我们应该优先考虑成员函数，这样更符合运算符重载的初衷；另外有一部分运算符重载必须是全局函数，这样能保证参数的对称性；除了 C++ 规定的几个特定的运算符外，暂时还没有发现必须以成员函数的形式重载的运算符。

> C++ 规定，箭头运算符`->`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符`=`只能以成员函数的形式重载。

## 6.5 C++重载>>和<<（输入和输出运算符）详解

### 重载输入运算符>>

下面我们以全局函数的形式重载`>>`，使它能够读入两个 double 类型的数据，并分别赋值给复数的实部和虚部：

```c
istream & operator>>(istream &in, complex &A){
    in >> A.m_real >> A.m_imag;
    return in;
}
```

istream 表示输入流，cin 是 istream 类的对象，只不过这个对象是在标准库中定义的。之所以返回 istream 类对象的引用，是为了能够连续读取复数，让代码书写更加漂亮，例如：

```c
complex c1, c2;
cin>>c1>>c2;
```

如果不返回引用，那就只能一个一个地读取了：

```c
complex c1, c2;
cin>>c1;
cin>>c2;
```

另外，运算符重载函数中用到了 complex 类的 private 成员变量，必须在 complex 类中将该函数声明为友元函数：

```c
friend istream & operator>>(istream & in , complex &a);
```

`>>`运算符可以按照下面的方式使用：

```c
complex c;cin>>c;
```

当输入`1.45 2.34↙`后，这两个小数就分别成为对象 c 的实部和虚部了。`cin>> c;`这一语句其实可以理解为：

```c
operator<<(cin , c);
```

### 重载输出运算符<<

同样地，我们也可以模仿上面的形式对输出运算符`>>`进行重载，让它能够输出复数，请看下面的代码：

```c
ostream & operator<<(ostream &out, complex &A){    out << A.m_real <<" + "<< A.m_imag <<" i ";    return out;}
```

ostream 表示输出流，cout 是 ostream 类的对象。由于采用了引用的方式进行参数传递，并且也返回了对象的引用，所以重载后的运算符可以实现连续输出。

为了能够直接访问 complex 类的 private 成员变量，同样需要将该函数声明为 complex 类的友元函数：

```c
friend ostream & operator<<(ostream &out, complex &A);
```

### 综合演示

结合输入输出运算符的重载，重新实现 complex 类：

```c
#include <iostream>using namespace std;class complex{public:    complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ };public:    friend complex operator+(const complex & A, const complex & B);    friend complex operator-(const complex & A, const complex & B);    friend complex operator*(const complex & A, const complex & B);    friend complex operator/(const complex & A, const complex & B);    friend istream & operator>>(istream & in, complex & A);    friend ostream & operator<<(ostream & out, complex & A);private:    double m_real;  //实部    double m_imag;  //虚部};//重载加法运算符complex operator+(const complex & A, const complex &B){    complex C;    C.m_real = A.m_real + B.m_real;    C.m_imag = A.m_imag + B.m_imag;    return C;}//重载减法运算符complex operator-(const complex & A, const complex &B){    complex C;    C.m_real = A.m_real - B.m_real;    C.m_imag = A.m_imag - B.m_imag;    return C;}//重载乘法运算符complex operator*(const complex & A, const complex &B){    complex C;    C.m_real = A.m_real * B.m_real - A.m_imag * B.m_imag;    C.m_imag = A.m_imag * B.m_real + A.m_real * B.m_imag;    return C;}//重载除法运算符complex operator/(const complex & A, const complex & B){    complex C;    double square = A.m_real * A.m_real + A.m_imag * A.m_imag;    C.m_real = (A.m_real * B.m_real + A.m_imag * B.m_imag)/square;    C.m_imag = (A.m_imag * B.m_real - A.m_real * B.m_imag)/square;    return C;}//重载输入运算符istream & operator>>(istream & in, complex & A){    in >> A.m_real >> A.m_imag;    return in;}//重载输出运算符ostream & operator<<(ostream & out, complex & A){    out << A.m_real <<" + "<< A.m_imag <<" i ";;    return out;}int main(){    complex c1, c2, c3;    cin>>c1>>c2;     c3 = c1 + c2;    cout<<"c1 + c2 = "<<c3<<endl;    c3 = c1 - c2;    cout<<"c1 - c2 = "<<c3<<endl;    c3 = c1 * c2;    cout<<"c1 * c2 = "<<c3<<endl;    c3 = c1 / c2;    cout<<"c1 / c2 = "<<c3<<endl;    return 0;}
```

运行结果：
2.4 3.6↙
4.8 1.7↙
c1 + c2 = 7.2 + 5.3 i
c1 - c2 = -2.4 + 1.9 i
c1 * c2 = 5.4 + 21.36 i
c1 / c2 = 0.942308 + 0.705128 i

## 6.6 C++重载[]（下标运算符）详解

[C++](http://c.biancheng.net/cplus/) 规定，下标运算符`[ ]`必须以成员函数的形式进行重载。该重载函数在类中的声明格式如下：

```c
返回值类型 & operator[ ] (参数);
```

或者：

```c
const 返回值类型 & operator[ ] (参数) const;
```

使用第一种声明方式，`[ ]`不仅可以访问元素，还可以修改元素。使用第二种声明方式，`[ ]`只能访问而不能修改元素。在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为[通过 const 对象只能调用 const 成员函数](http://c.biancheng.net/view/2232.html)，如果不提供第二种形式，那么将无法访问 const 对象的任何元素。

下面我们通过一个具体的例子来演示如何重载`[ ]`。我们知道，有些较老的编译器不支持[变长数组](http://c.biancheng.net/view/vip_1837.html)，例如 VC6.0、VS2010 等，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组。

```c
#include <iostream>using namespace std;class Array{public:    Array(int length = 0);    ~Array();public:    int & operator[](int i);    const int & operator[](int i) const;public:    int length() const { return m_length; }    void display() const;private:    int m_length;  //数组长度    int *m_p;  //指向数组内存的指针};Array::Array(int length): m_length(length){    if(length == 0){        m_p = NULL;    }else{        m_p = new int[length];    }}Array::~Array(){    delete[] m_p;}int& Array::operator[](int i){    return m_p[i];}const int & Array::operator[](int i) const{    return m_p[i];}void Array::display() const{    for(int i = 0; i < m_length; i++){        if(i == m_length - 1){            cout<<m_p[i]<<endl;        }else{            cout<<m_p[i]<<", ";        }    }}int main(){    int n;    cin>>n;    Array A(n);    for(int i = 0, len = A.length(); i < len; i++){        A[i] = i * 5;    }    A.display();       const Array B(n);    cout<<B[n-1]<<endl;  //访问最后一个元素       return 0;}
```

运行结果：
5↙
0, 5, 10, 15, 20
33685536

重载`[ ]`运算符以后，表达式`arr[i]`会被转换为：

```c
arr.operator[ ](i);
```

需要说明的是，B 是 const 对象，如果 Array 类没有提供 const 版本的`operator[ ]`，那么第 60 行代码将报错。虽然第 60 行代码只是读取对象的数据，并没有试图修改对象，但是它调用了非 const 版本的`operator[ ]`，编译器不管实际上有没有修改对象，只要是调用了非 const 的成员函数，编译器就认为会修改对象（至少有这种风险）。

## 6.7 C++重载++和--（自增和自减运算符）详解

自增`++`和自减`--`都是一元运算符，它的前置形式和后置形式都可以被重载。请看下面的例子：

```c
#include <iostream>#include <iomanip>using namespace std;//秒表类class stopwatch{public:    stopwatch(): m_min(0), m_sec(0){ }public:    void setzero(){ m_min = 0; m_sec = 0; }    stopwatch run();  // 运行    stopwatch operator++();  //++i，前置形式    stopwatch operator++(int);  //i++，后置形式    friend ostream & operator<<( ostream &, const stopwatch &);private:    int m_min;  //分钟    int m_sec;  //秒钟};stopwatch stopwatch::run(){    ++m_sec;    if(m_sec == 60){        m_min++;        m_sec = 0;    }    return *this;}stopwatch stopwatch::operator++(){    return run();}stopwatch stopwatch::operator++(int n){    stopwatch s = *this;    run();    return s;}ostream &operator<<( ostream & out, const stopwatch & s){    out<<setfill('0')<<setw(2)<<s.m_min<<":"<<setw(2)<<s.m_sec;    return out;}int main(){    stopwatch s1, s2;    s1 = s2++;    cout << "s1: "<< s1 <<endl;    cout << "s2: "<< s2 <<endl;    s1.setzero();    s2.setzero();    s1 = ++s2;    cout << "s1: "<< s1 <<endl;    cout << "s2: "<< s2 <<endl;    return 0;}
```

运行结果：
s1: 00:00
s2: 00:01
s1: 00:01
s2: 00:01

上面的代码定义了一个简单的秒表类，m_min 表示分钟，m_sec 表示秒钟，setzero() 函数用于秒表清零，run() 函数是用来描述秒针前进一秒的动作，接下来是三个运算符重载函数。

先来看一下 run() 函数的实现，run() 函数一开始让秒针自增，如果此时自增结果等于60了，则应该进位，分钟加1，秒针置零。

operator++() 函数实现自增的前置形式，直接返回 run() 函数运行结果即可。

operator++ (int n) 函数实现自增的后置形式，返回值是对象本身，但是之后再次使用该对象时，对象自增了，所以在该函数的函数体中，先将对象保存，然后调用一次 run() 函数，之后再将先前保存的对象返回。在这个函数中参数n是没有任何意义的，它的存在只是为了区分是前置形式还是后置形式。

自减运算符的重载与上面类似，这里不再赘述。

## 6.8 C++重载new和delete运算符详解

内存管理运算符 new、new[]、delete 和 delete[] 也可以进行重载，其重载形式既可以是类的成员函数，也可以是全局函数。一般情况下，内建的内存管理运算符就够用了，只有在需要自己管理内存时才会重载。

以成员函数的形式重载 new 运算符：

```c
void * className::operator new( size_t size ){  //TODO:}
```

以全局函数的形式重载 new 运算符：

```c
void * operator new( size_t size ){  //TODO:}
```

两种重载形式的返回值相同，都是`void *`类型，并且都有一个参数，为`size_t`类型。在重载 new 或 new[] 时，无论是作为成员函数还是作为全局函数，它的第一个参数必须是 size_t 类型。size_t 表示的是要分配空间的大小，对于 new[] 的重载函数而言，size_t 则表示所需要分配的所有空间的总和。

> size_t 在头文件 <cstdio> 中被定义为`typedef unsigned int size_t;`，也就是无符号整型。

当然，重载函数也可以有其他参数，但都必须有默认值，并且第一个参数的类型必须是 size_t。

同样的，delete 运算符也有两种重载形式。以类的成员函数的形式进行重载：

```c
void className::operator delete( void *ptr){  //TODO:}
```

以全局函数的形式进行重载：

```c
void operator delete( void *ptr){  //TODO:}
```

两种重载形式的返回值都是 void 类型，并且都必须有一个 void 类型的[指针](http://c.biancheng.net/c/80/)作为参数，该指针指向需要释放的内存空间。

当我们以类的成员函数的形式重载了new 和 delete 操作符，其使用方法如下：

```c
C * c = new C;  //分配内存空间//TODO:delete c;  //释放内存空间
```

如果类中没有定义 new 和 delete 的重载函数，那么会自动调用内建的 new 和 delete 运算符。

## 6.9 C++重载()（强制类型转换运算符）

在 [C++](http://c.biancheng.net/cplus/) 中，类型的名字（包括类的名字）本身也是一种运算符，即类型强制转换运算符。

类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。经过适当重载后，`(类型名)对象`这个对对象进行强制类型转换的表达式就等价于`对象.operator 类型名()`，即变成对运算符函数的调用。

下面的程序对 double 类型强制转换运算符进行了重载。

```c
#include <iostream>using namespace std;class Complex{    double real, imag;public:    Complex(double r = 0, double i = 0) :real(r), imag(i) {};    operator double() { return real; }  //重载强制类型转换运算符 double};int main(){    Complex c(1.2, 3.4);    cout << (double)c << endl;  //输出 1.2    double n = 2 + c;  //等价于 double n = 2 + c. operator double()    cout << n;  //输出 3.2}
```

程序的输出结果是：
1.2
3.2

第 8 行对 double 运算符进行了重载。重载强制类型转换运算符时，不需要指定返回值类型，因为返回值类型是确定的，就是运算符本身代表的类型，在这里就是 double。

重载后的效果是，第 13 行的`(double)c`等价于`c.operator double()`。

有了对 double 运算符的重载，在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用。

例如第 14 行，编译器认为本行中`c`这个位置如果出现的是 double 类型的数据，就能够解释得通，而 Complex 类正好重载了 double 运算符，因而本行就等价于：

```c
double n = 2 + c.operator double();
```

## 6.10 C++运算符重载注意事项以及汇总

在 [C++](http://c.biancheng.net/cplus/) 中进行运算符重载时，有以下问题需要注意：

- 重载后运算符的含义应该符合原有用法习惯。例如重载`+`运算符，完成的功能就应该类似于做加法，在重载的`+`运算符中做减法是不合适的。此外，重载应尽量保留运算符原有的特性。
- C++ 规定，运算符重载不改变运算符的优先级。
- 以下运算符不能被重载：`.`、`.*`、`::`、`? :`、`sizeof`。
- 重载运算符`()`、`[]`、`->`、或者赋值运算符`=`时，只能将它们重载为成员函数，不能重载为全局函数。


运算符重载的实质是将运算符重载为一个函数，使用运算符的表达式就被解释为对重载函数的调用。

运算符可以重载为全局函数。此时函数的参数个数就是运算符的操作数个数，运算符的操作数就成为函数的实参。

运算符也可以重载为成员函数。此时函数的参数个数就是运算符的操作数个数减一，运算符的操作数有一个成为函数作用的对象，其余的成为函数的实参。

必要时需要重载赋值运算符=，以避免两个对象内部的[指针](http://c.biancheng.net/c/80/)指向同一片存储空间。

运算符可以重载为全局函数，然后声明为类的友元。

<<和>>是在 iostream 中被重载，才成为所谓的“流插入运算符”和“流提取运算符”的。

类型的名字可以作为强制类型转换运算符，也可以被重载为类的成员函数。它能使得对象被自动转换为某种类型。

自增、自减运算符各有两种重载方式，用于区别前置用法和后置用法。

运算符重载不改变运算符的优先级。重载运算符时，应该尽量保留运算符原本的特性。

# 7 模板

## 7.1 C++函数模板5分钟入门教程

我们知道，数据的值可以通过函数参数传递，在函数定义时数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。这就是值的参数化。

在[C++](http://c.biancheng.net/cplus/)中，数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化。

值（Value）和类型（Type）是数据的两个主要特征，它们在C++中都可以被参数化。

所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为**函数模板（Function Template）**。

在函数模板中，数据的值和类型都被参数化了，发生函数调用时编译器会根据传入的实参来推演形参的值和类型。换个角度说，函数模板除了支持值的参数化，还支持类型的参数化。

一但定义了函数模板，就可以将类型参数用于函数定义和函数声明了。

```ABAP
#include <iostream>using namespace std;template<typename T> void Swap(T *a, T *b){    T temp = *a;    *a = *b;    *b = temp;}int main(){    //交换 int 变量的值    int n1 = 100, n2 = 200;    Swap(&n1, &n2);    cout<<n1<<", "<<n2<<endl;       //交换 float 变量的值    float f1 = 12.5, f2 = 56.93;    Swap(&f1, &f2);    cout<<f1<<", "<<f2<<endl;       //交换 char 变量的值    char c1 = 'A', c2 = 'B';    Swap(&c1, &c2);    cout<<c1<<", "<<c2<<endl;       //交换 bool 变量的值    bool b1 = false, b2 = true;    Swap(&b1, &b2);    cout<<b1<<", "<<b2<<endl;    return 0;}
```

运行结果：
200, 100
56.93, 12.5
B, A
1, 0

请读者重点关注第 4 行代码。`template`是定义函数模板的关键字，它后面紧跟尖括号`<>`，尖括号包围的是类型参数（也可以说是虚拟的类型，或者说是类型占位符）。`typename`是另外一个关键字，用来声明具体的类型参数，这里的类型参数就是`T`。从整体上看，`template<typename T>`被称为模板头。

模板头中包含的类型参数可以用在函数定义的各个位置，包括返回值、形参列表和函数体；本例我们在形参列表和函数体中使用了类型参数`T`。

类型参数的命名规则跟其他标识符的命名规则一样，不过使用 T、T1、T2、Type 等已经成为了一种惯例。

定义了函数模板后，就可以像调用普通函数一样来调用它们了。

在讲解[C++函数重载](http://c.biancheng.net/view/2206.html)时我们还没有学到引用（Reference），为了达到交换两个变量的值的目的只能使用[指针](http://c.biancheng.net/c/80/)，而现在我们已经对引用进行了深入讲解，不妨趁此机会来实践一把，使用引用重新实现 Swap() 这个函数模板：

```c
#include <iostream>using namespace std;template<typename T> void Swap(T &a, T &b){    T temp = a;    a = b;    b = temp;}int main(){    //交换 int 变量的值    int n1 = 100, n2 = 200;    Swap(n1, n2);    cout<<n1<<", "<<n2<<endl;       //交换 float 变量的值    float f1 = 12.5, f2 = 56.93;    Swap(f1, f2);    cout<<f1<<", "<<f2<<endl;       //交换 char 变量的值    char c1 = 'A', c2 = 'B';    Swap(c1, c2);    cout<<c1<<", "<<c2<<endl;       //交换 bool 变量的值    bool b1 = false, b2 = true;    Swap(b1, b2);    cout<<b1<<", "<<b2<<endl;    return 0;}
```

引用不但使得函数定义简洁明了，也使得调用函数方便了很多。整体来看，引用让编码更加漂亮。

下面我们来总结一下定义模板函数的语法：

```c
template <typename 类型参数1 , typename 类型参数2 , ...> 返回值类型  函数名(形参列表){  //在函数体中可以使用类型参数}
```

类型参数可以有多个，它们之间以逗号`,`分隔。类型参数列表以`< >`包围，形式参数列表以`( )`包围。

`typename`关键字也可以使用`class`关键字替代，它们没有任何区别。C++ 早期对模板的支持并不严谨，没有引入新的关键字，而是用 class 来指明类型参数，但是 class 关键字本来已经用在类的定义中了，这样做显得不太友好，所以后来 C++ 又引入了一个新的关键字 typename，专门用来定义类型参数。不过至今仍然有很多代码在使用 class 关键字，包括 C++ 标准库、一些开源程序等。

本教程会交替使用 typename 和 class，旨在让读者在别的地方遇到它们时不会感觉陌生。更改上面的 Swap() 函数，使用 class 来指明类型参数：

```c
template<class T> void Swap(T &a, T &b){    T temp = a;    a = b;    b = temp;}
```

除了将 typename 替换为 class，其他都是一样的。

为了加深对函数模板的理解，我们再来看一个求三个数的最大值的例子：

```c
#include <iostream>using namespace std;//声明函数模板template<typename T> T max(T a, T b, T c);int main( ){    //求三个整数的最大值    int i1, i2, i3, i_max;    cin >> i1 >> i2 >> i3;    i_max = max(i1,i2,i3);    cout << "i_max=" << i_max << endl;    //求三个浮点数的最大值    double d1, d2, d3, d_max;    cin >> d1 >> d2 >> d3;    d_max = max(d1,d2,d3);    cout << "d_max=" << d_max << endl;    //求三个长整型数的最大值    long g1, g2, g3, g_max;    cin >> g1 >> g2 >> g3;    g_max = max(g1,g2,g3);    cout << "g_max=" << g_max << endl;    return 0;}//定义函数模板template<typename T>  //模板头，这里不能有分号T max(T a, T b, T c){ //函数头    T max_num = a;    if(b > max_num) max_num = b;    if(c > max_num) max_num = c;    return max_num;}
```

运行结果：
12 34 100↙
i_max=100
73.234 90.2 878.23↙
d_max=878.23
344 900 1000↙
g_max=1000

函数模板也可以提前声明，不过声明时需要带上模板头，并且模板头和函数定义（声明）是一个不可分割的整体，它们可以换行，但中间不能有分号。

## 7.2 C++类模板5分钟入门教程

[C++](http://c.biancheng.net/cplus/) 除了支持[函数模板](http://c.biancheng.net/view/2317.html)，还支持**类模板（Class Template）**。函数模板中定义的类型参数可以用在函数声明和函数定义中，类模板中定义的类型参数可以用在类声明和类实现中。类模板的目的同样是将数据的类型参数化。

声明类模板的语法为：

```c++
template<typename 类型参数1 , typename 类型参数2 , …> class 类名{  //TODO:};
```

类模板和函数模板都是以 template 开头（当然也可以使用 class，目前来讲它们没有任何区别），后跟类型参数；类型参数不能为空，多个类型参数用逗号隔开。

一但声明了类模板，就可以将类型参数用于类的成员函数和成员变量了。换句话说，原来使用 int、float、char 等内置类型的地方，都可以用类型参数来代替。

假如我们现在要定义一个类来表示坐标，要求坐标的数据类型可以是整数、小数和字符串，例如：

- x = 10、y = 10
- x = 12.88、y = 129.65
- x = "东经180度"、y = "北纬210度"


这个时候就可以使用类模板，请看下面的代码：

```c++
template<typename T1, typename T2>  //这里不能有分号class Point{public:    Point(T1 x, T2 y): m_x(x), m_y(y){ }public:    T1 getX() const;  //获取x坐标    void setX(T1 x);  //设置x坐标    T2 getY() const;  //获取y坐标    void setY(T2 y);  //设置y坐标private:    T1 m_x;  //x坐标    T2 m_y;  //y坐标};
```

x 坐标和 y 坐标的数据类型不确定，借助类模板可以将数据类型参数化，这样就不必定义多个类了。

> 注意：模板头和类头是一个整体，可以换行，但是中间不能有分号。

上面的代码仅仅是类的声明，我们还需要在类外定义成员函数。在类外定义成员函数时仍然需要带上模板头，格式为：

```c++
template<typename 类型参数1 , typename 类型参数2 , …>返回值类型 类名<类型参数1 , 类型参数2, ...>::函数名(形参列表){  //TODO:}
```

第一行是模板头，第二行是函数头，它们可以合并到一行，不过为了让代码格式更加清晰，一般是将它们分成两行。

下面就对 Point 类的成员函数进行定义：

```c++
template<typename T1, typename T2>  //模板头T1 Point<T1, T2>::getX() const /*函数头*/ {    return m_x;}template<typename T1, typename T2>void Point<T1, T2>::setX(T1 x){    m_x = x;}template<typename T1, typename T2>T2 Point<T1, T2>::getY() const{    return m_y;}template<typename T1, typename T2>void Point<T1, T2>::setY(T2 y){    m_y = y;}
```

请读者仔细观察代码，除了 template 关键字后面要指明类型参数，类名 Point 后面也要带上类型参数，只是不加 typename 关键字了。另外需要注意的是，在类外定义成员函数时，template 后面的类型参数要和类声明时的一致。

### 使用类模板创建对象

上面的两段代码完成了类的定义，接下来就可以使用该类创建对象了。使用类模板创建对象时，需要指明具体的数据类型。请看下面的代码：

```c++
Point<int, int> p1(10, 20);Point<int, float> p2(10, 15.5);Point<float, char*> p3(12.4, "东经180度");
```

与函数模板不同的是，类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。

除了对象变量，我们也可以使用对象[指针](http://c.biancheng.net/c/80/)的方式来实例化：

```c++
Point<float, float> *p1 = new Point<float, float>(10.6, 109.3);Point<char*, char*> *p = new Point<char*, char*>("东经180度", "北纬210度");
```

需要注意的是，赋值号两边都要指明具体的数据类型，且要保持一致。下面的写法是错误的：

```c++
//赋值号两边的数据类型不一致Point<float, float> *p = new Point<float, int>(10.6, 109);//赋值号右边没有指明数据类型Point<float, float> *p = new Point(10.6, 109);
```

### 综合示例

【实例1】将上面的类定义和类实例化的代码整合起来，构成一个完整的示例，如下所示：

```c++
#include <iostream>using namespace std;template<class T1, class T2>  //这里不能有分号class Point{public:    Point(T1 x, T2 y): m_x(x), m_y(y){ }public:    T1 getX() const;  //获取x坐标    void setX(T1 x);  //设置x坐标    T2 getY() const;  //获取y坐标    void setY(T2 y);  //设置y坐标private:    T1 m_x;  //x坐标    T2 m_y;  //y坐标};template<class T1, class T2>  //模板头T1 Point<T1, T2>::getX() const /*函数头*/ {    return m_x;}template<class T1, class T2>void Point<T1, T2>::setX(T1 x){    m_x = x;}template<class T1, class T2>T2 Point<T1, T2>::getY() const{    return m_y;}template<class T1, class T2>void Point<T1, T2>::setY(T2 y){    m_y = y;}int main(){    Point<int, int> p1(10, 20);    cout<<"x="<<p1.getX()<<", y="<<p1.getY()<<endl;     Point<int, char*> p2(10, "东经180度");    cout<<"x="<<p2.getX()<<", y="<<p2.getY()<<endl;     Point<char*, char*> *p3 = new Point<char*, char*>("东经180度", "北纬210度");    cout<<"x="<<p3->getX()<<", y="<<p3->getY()<<endl;    return 0;}
```

运行结果：
x=10, y=20
x=10, y=东经180度
x=东经180度, y=北纬210度

在定义类型参数时我们使用了 class，而不是 typename，这样做的目的是让读者对两种写法都熟悉。

【实例2】用类模板实现可变长数组。

```c++
#include <iostream>#include <cstring>using namespace std;template <class T>class CArray{    int size; //数组元素的个数    T *ptr; //指向动态分配的数组public:    CArray(int s = 0);  //s代表数组元素的个数    CArray(CArray & a);    ~CArray();    void push_back(const T & v); //用于在数组尾部添加一个元素v    CArray & operator=(const CArray & a); //用于数组对象间的赋值    T length() { return size; }    T & operator[](int i)    {//用以支持根据下标访问数组元素，如a[i] = 4;和n = a[i]这样的语句        return ptr[i];    }};template<class T>CArray<T>::CArray(int s):size(s){     if(s == 0)         ptr = NULL;    else        ptr = new T[s];}template<class T>CArray<T>::CArray(CArray & a){    if(!a.ptr) {        ptr = NULL;        size = 0;        return;    }    ptr = new T[a.size];    memcpy(ptr, a.ptr, sizeof(T ) * a.size);    size = a.size;}template <class T>CArray<T>::~CArray(){     if(ptr) delete [] ptr;}template <class T>CArray<T> & CArray<T>::operator=(const CArray & a){ //赋值号的作用是使"="左边对象里存放的数组，大小和内容都和右边的对象一样    if(this == & a) //防止a=a这样的赋值导致出错    return * this;    if(a.ptr == NULL) {  //如果a里面的数组是空的        if( ptr )            delete [] ptr;        ptr = NULL;        size = 0;        return * this;    }     if(size < a.size) { //如果原有空间够大，就不用分配新的空间         if(ptr)            delete [] ptr;        ptr = new T[a.size];    }    memcpy(ptr,a.ptr,sizeof(T)*a.size);       size = a.size;     return *this;}template <class T>void CArray<T>::push_back(const T & v){  //在数组尾部添加一个元素    if(ptr) {        T *tmpPtr = new T[size+1]; //重新分配空间    memcpy(tmpPtr,ptr,sizeof(T)*size); //拷贝原数组内容    delete []ptr;    ptr = tmpPtr;}    else  //数组本来是空的        ptr = new T[1];    ptr[size++] = v; //加入新的数组元素}int main(){    CArray<int> a;    for(int i = 0;i < 5;++i)        a.push_back(i);    for(int i = 0; i < a.length(); ++i)        cout << a[i] << " ";       return 0;}
```

## 7.4 C++函数模板的重载

当需要对不同的类型使用同一种算法（同一个函数体）时，为了避免定义多个功能重复的函数，可以使用模板。然而，并非所有的类型都使用同一种算法，有些特定的类型需要单独处理，为了满足这种需求，C++ 允许对函数模板进行重载，程序员可以像重载常规函数那样重载模板定义。

在《[C++函数模板](http://c.biancheng.net/view/2317.html)》一节中我们定义了 Swap() 函数用来交换两个变量的值，一种方案是使用指针，另外一种方案是使用引用，请看下面的代码：

```c++
//方案①：使用指针template<typename T> void Swap(T *a, T *b){    T temp = *a;    *a = *b;    *b = temp;}//方案②：使用引用template<class T> void Swap(T &a, T &b){    T temp = a;    a = b;    b = temp;}
```

这两种方案都可以交换 int、float、char、bool 等基本类型变量的值，但是却不能交换两个数组。

对于方案①，调用函数时传入的是数组指针，或者说是指向第 0  个元素的指针，这样交换的仅仅是数组的第 0 个元素，而不是整个数组。数组和指针本来是不等价的，只是当函数的形参为指针时，传递的数组也会隐式地转换为指针，这在《[C语言入门教程](http://c.biancheng.net/c/)》中的《[数组和指针绝不等价，数组是另外一种类型](http://c.biancheng.net/view/vip_2018.html)》《[数组到底在什么时候会转换为指针](http://c.biancheng.net/view/vip_2019.html)》两节中做了详细讲解，不了解的读者请猛击链接深入学习。

对于方案②，假设传入的是一个长度为 5 的 int 类型数组（该数组的类型是 int [5]），那么 T 的真实类型为`int [5]`，`T temp`会被替换为`int [5] temp`，这显然是错误的。另外一方面，语句`a=b;`尝试对数组 a 赋值，而数组名是常量，它的值不允许被修改，所以也会产生错误。总起来说，方案②会有两处语法错误。

交换两个数组唯一的办法就是逐个交换所有的数组元素，请看下面的代码：

```c++
template<typename T> void Swap(T a[], T b[], int len){    T temp;    for(int i=0; i<len; i++){        temp = a[i];        a[i] = b[i];        b[i] = temp;    }}
```

在该函数模板中，最后一个参数的类型为具体类型（int），而不是泛型。并不是所有的模板参数都必须被泛型化。

下面是一个重载函数模板的完整示例：

```c++
#include <iostream>using namespace std;template<class T> void Swap(T &a, T &b);  //模板①：交换基本类型的值template<typename T> void Swap(T a[], T b[], int len);  //模板②：交换两个数组void printArray(int arr[], int len);  //打印数组元素int main(){    //交换基本类型的值    int m = 10, n = 99;    Swap(m, n);  //匹配模板①    cout<<m<<", "<<n<<endl;    //交换两个数组    int a[5] = { 1, 2, 3, 4, 5 };    int b[5] = { 10, 20, 30, 40, 50 };    int len = sizeof(a) / sizeof(int);  //数组长度    Swap(a, b, len);  //匹配模板②    printArray(a, len);    printArray(b, len);    return 0;}template<class T> void Swap(T &a, T &b){    T temp = a;    a = b;    b = temp;}template<typename T> void Swap(T a[], T b[], int len){    T temp;    for(int i=0; i<len; i++){        temp = a[i];        a[i] = b[i];        b[i] = temp;    }}void printArray(int arr[], int len){    for(int i=0; i<len; i++){        if(i == len-1){            cout<<arr[i]<<endl;        }else{            cout<<arr[i]<<", ";        }    }}
```

运行结果：
99, 10
10, 20, 30, 40, 50
1, 2, 3, 4, 5

## 7.5 C++函数模板的实参推断

在使用类模板创建对象时，程序员需要显式的指明实参（也就是具体的类型）。例如对于下面的 Point 类：

```c++
template<typename T1, typename T2> class Point;
```

我们可以在栈上创建对象，也可以在堆上创建对象：

```c++
Point<int, int> p1(10, 20);  //在栈上创建对象Point<char*, char*> *p = new Point<char*, char*>("东京180度", "北纬210度");  //在堆上创建对象
```

因为已经显式地指明了 T1、T2 的具体类型，所以编译器就不用再自己推断了，直接拿来使用即可。

而对于函数模板，调用函数时可以不显式地指明实参（也就是具体的类型）。请看下面的例子：

```c++
//函数声明template<typename T> void Swap(T &a, T &b);//函数调用int n1 = 100, n2 = 200;Swap(n1, n2);float f1 = 12.5, f2 = 56.93;Swap(f1, f2);
```

虽然没有显式地指明 T 的具体类型，但是编译器会根据 n1 和 n2、f1 和 f2 的类型自动推断出 T 的类型。这种通过函数实参来确定模板实参（也就是类型参数的具体类型）的过程称为模板实参推断。

在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找类型参数的具体类型。

### 模板实参推断过程中的类型转换

对于普通函数（非模板函数），发生函数调用时会对实参的类型进行适当的转换，以适应形参的类型。这些转换包括：

- 算数转换：例如 int 转换为 float，char 转换为 int，double 转换为 int 等。
- 派生类向基类的转换：也就是向上转型，请猛击《[C++向上转型（将派生类赋值给基类）](http://c.biancheng.net/view/2284.html)》了解详情。
- const 转换：也即将非 const 类型转换为 const 类型，例如将 char * 转换为 const char *。
- 数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。
- 用户自定的类型转换。


例如有下面两个函数原型：

```c++
void func1(int n, float f);void func2(int *arr, const char *str);
```

它们具体的调用形式为：

```c++
int nums[5];char *url = "http://c.biancheng.net";func1(12.5, 45);func2(nums, url);
```

对于 func1()，12.5 会从`double`转换为`int`，45 会从`int`转换为`float`；对于 func2()，nums 会从`int [5]`转换为`int *`，url 会从`char *`转换为`const char *`。

而对于函数模板，类型转换则受到了更多的限制，仅能进行「const 转换」和「数组或函数指针转换」，其他的都不能应用于函数模板。例如有下面几个函数模板：

```c++
template<typename T> void func1(T a, T b);template<typename T> void func2(T *buffer);template<typename T> void func3(const T &stu);template<typename T> void func4(T a);template<typename T> void func5(T &a);
```

它们具体的调用形式为：

```c++
int name[20];Student stu1("张华", 20, 96.5);  //创建一个Student类型的对象func1(12.5, 30);  //Errorfunc2(name);  //name的类型从 int [20] 换转换为 int *，所以 T 的真实类型为 intfunc3(stu1);  //非const转换为const，T 的真实类型为 Studentfunc4(name);  //name的类型从 int [20] 换转换为 int *，所以 T 的真实类型为 int *func5(name);  //name的类型依然为 int [20]，不会转换为 int *，所以 T 的真实类型为 int [20]
```

对于`func1(12.5, 30)`，12.5 的类型为 double，30 的类型为 int，编译器不知道该将 T 实例化为 double 还是 int，也不会尝试将 int 转换为 double，或者将 double 转换为 int，所以调用失败。

请读者注意 name，它本来的类型是`int [20]`：

- 对于`func2(name)`和`func4(name)`，name 的类型会从 int [20] 转换为 int *，也即将数组转换为指针，所以 T 的类型分别为 int * 和 int。
- 对于`func5(name)`，name 的类型依然为 int [20]，不会转换为 int *，所以 T 的类型为 int [20]。


可以发现，当函数形参是引用类型时，数组不会转换为指针。这个时候读者要注意下面这样的函数模板：

```c++
template<typename T> void func(T &a, T &b);
```

如果它的具体调用形式为：

```c++
int str1[20];int str2[10];func(str1, str2);
```

由于 str1、str2 的类型分别为 int [20] 和 int [10]，在函数调用过程中又不会转换为指针，所以编译器不知道应该将 T 实例化为 int [20] 还是 int [10]，导致调用失败。

### 为函数模板显式地指明实参（也就是具体的类型）

函数模板的实参推断是指「在函数调用过程中根据实参的类型来寻找类型参数的具体类型」的过程，这在大部分情况下是奏效的，但是当类型参数的个数较多时，就会有个别的类型无法推断出来，这个时候就必须显式地指明实参。

下面是一个实参推断失败的例子：

```c++
template<typename T1, typename T2> void func(T1 a){    T2 b;}func(10);  //函数调用
```

func() 有两个类型参数，分别是 T1 和 T2，但是编译器只能从函数调用中推断出 T1 的类型来，不能推断出 T2 的类型来，所以这种调用是失败的，这个时候就必须显式地指明 T1、T2 的具体类型。

「为函数模板显式地指明实参」和「为类模板显式地指明实参」的形式是类似的，就是在函数名后面添加尖括号`< >`，里面包含具体的类型。例如对于上面的 func()，我们要这样来指明实参：

```c++
func<int, int>(10);
```

显式指明的模板实参会按照从左到右的顺序与对应的模板参数匹配：第一个实参与第一个模板参数匹配，第二个实参与第二个模板参数匹配，以此类推。只有尾部（最右）的类型参数的实参可以省略，而且前提是它们可以从传递给函数的实参中推断出来。

对于上面的 func()，虽然只有 T2 的类型不能自动推断出来，但是由于它位于类型参数列表的尾部（最右），所以必须同时指明 T1 和 T2 的类型。对代码稍微做出修改：

```c++
template<typename T1, typename T2> void func(T2 a){    T1 b;}//函数调用func<int>(10);  //省略 T2 的类型func<int, int>(20);  //指明 T1、T2 的类型
```

由于 T2 的类型能够自动推断出来，并且它位于参数列表的尾部（最右），所以可以省略。

## 显式地指明实参时可以应用正常的类型转换

### 上面我们提到，函数模板仅能进行「const 转换」和「数组或函数指针转换」两种形式的类型转换，但是当我们显式地指明类型参数的实参（具体类型）时，就可以使用正常的类型转换（非模板函数可以使用的类型转换）了。

例如对于下面的函数模板：

```c++
template<typename T> void func(T a, T b);
```

它的具体调用形式如下：

```c
func(10, 23.5);  //Errorfunc<float>(20, 93.7);  //Correct
```

在第二种调用形式中，我们已经显式地指明了 T 的类型为 float，编译器不会再为「T 的类型到底是 int 还是 double」而纠结了，所以可以从容地使用正常的类型转换了。

## 7.6 C++模板的显式具体化

C++ 没有办法限制类型参数的范围，我们可以使用任意一种类型来实例化模板。但是模板中的语句（函数体或者类体）不一定就能适应所有的类型，可能会有个别的类型没有意义，或者会导致语法错误。

例如有下面的函数模板，它用来获取两个变量中较大的一个：

```c++
template<class T> const T& Max(const T& a, const T& b){    return a > b ? a : b;}
```

请读者注意`a > b`这条语句，`>`能够用来比较 int、float、char 等基本类型数据的大小，但是却不能用来比较结构体变量、对象以及数组的大小，因为我们并没有针对结构体、类和数组重载`>`。

另外，该函数模板虽然可以用于指针，但比较的是地址大小，而不是指针指向的数据，所以也没有现实的意义。

除了`>`，`+``-``*``/``==``<`等运算符也只能用于基本类型，不能用于结构体、类、数组等复杂类型。总之，编写的函数模板很可能无法处理某些类型，我们必须对这些类型进行单独处理。

模板是一种泛型技术，它能接受的类型是宽泛的、没有限制的，并且对这些类型使用的算法都是一样的（函数体或类体一样）。但是现在我们希望改变这种“游戏规则”，让模板能够针对某种具体的类型使用不同的算法（函数体或类体不同），这在 C++ 中是可以做到的，这种技术称为模板的**显示具体化（Explicit Specialization）**。

函数模板和类模板都可以显示具体化，下面我们先讲解函数模板的显示具体化，再讲解类模板的显示具体化。

### 函数模板的显式具体化

在讲解函数模板的显示具体化语法之前，我们先来看一个显示具体化的例子：

```c++
#include <iostream>#include <string>using namespace std;typedef struct{    string name;    int age;    float score;} STU;//函数模板template<class T> const T& Max(const T& a, const T& b);//函数模板的显示具体化（针对STU类型的显示具体化）template<> const STU& Max<STU>(const STU& a, const STU& b);//重载<<ostream & operator<<(ostream &out, const STU &stu);int main(){    int a = 10;    int b = 20;    cout<<Max(a, b)<<endl;       STU stu1 = { "王明", 16, 95.5};    STU stu2 = { "徐亮", 17, 90.0};    cout<<Max(stu1, stu2)<<endl;    return 0;}template<class T> const T& Max(const T& a, const T& b){    return a > b ? a : b;}template<> const STU& Max<STU>(const STU& a, const STU& b){    return a.score > b.score ? a : b;}ostream & operator<<(ostream &out, const STU &stu){    out<<stu.name<<" , "<<stu.age <<" , "<<stu.score;    return out;}
```

运行结果：
20
王明 , 16 , 95.5

本例中，STU 结构体用来表示一名学生(Student)，它有三个成员，分别是姓名(name)、年龄(age)、成绩(score)；Max() 函数用来获取两份数据中较大的一份。

要想获取两份数据中较大的一份，必然会涉及到对两份数据的比较。对于 int、float、char 等基本类型的数据，直接比较它们本身的值即可，而对于 STU 类型的数据，直接比较它们本身的值不但会有语法错误，而且毫无意义，这就要求我们设计一套不同的比较方案，从语法和逻辑上都能行得通，所以本例中我们比较的是两名学生的成绩（score）。

不同的比较方案最终导致了算法（函数体）的不同，我们不得不借助模板的显示具体化技术对 STU 类型进行单独处理。第 14 行代码就是显示具体化的声明，第 34 行代码进行了定义。

请读者注意第 34 行代码，`Max<STU>`中的`STU`表明了要将类型参数 T 具体化为 STU 类型，原来使用 T 的位置都应该使用 STU 替换，包括返回值类型、形参类型、局部变量的类型。

Max 只有一个类型参数 T，并且已经被具体化为 STU 了，这样整个模板就不再有类型参数了，类型参数列表也就为空了，所以模板头应该写作`template<>`。

另外，`Max<STU>`中的`STU`是可选的，因为函数的形参已经表明，这是 STU 类型的一个具体化，编译器能够逆推出 T 的具体类型。简写后的函数声明为：

```c++
template<> const STU& Max(const STU& a, const STU& b);
```



#### 函数的调用规则

回顾一下前面学习到的知识，在 C++ 中，对于给定的函数名，可以有非模板函数、模板函数、显示具体化模板函数以及它们的重载版本，在调用函数时，显示具体化优先于常规模板，而非模板函数优先于显示具体化和常规模板。

### 类模板的显式具体化

除了函数模板，类模板也可以显示具体化，并且它们的语法是类似的。

在《[C++类模板](http://c.biancheng.net/view/2318.html)》一节中我们定义了一个 Point 类，用来输出不同类型的坐标。在输出结果中，横坐标 x 和纵坐标 y 是以逗号`,`为分隔的，但是由于个人审美的不同，我希望当 x 和 y 都是字符串时以`|`为分隔，是数字或者其中一个是数字时才以逗号`,`为分隔。为了满足我这种奇葩的要求，可以使用显示具体化技术对字符串类型的坐标做特殊处理。

下面的例子演示了如何对 Point 类进行显示具体化：

```c++
#include <iostream>using namespace std;//类模板template<class T1, class T2> class Point{public:    Point(T1 x, T2 y): m_x(x), m_y(y){ }public:    T1 getX() const{ return m_x; }    void setX(T1 x){ m_x = x; }    T2 getY() const{ return m_y; }    void setY(T2 y){ m_y = y; }    void display() const;private:    T1 m_x;    T2 m_y;};template<class T1, class T2>  //这里要带上模板头void Point<T1, T2>::display() const{    cout<<"x="<<m_x<<", y="<<m_y<<endl;}//类模板的显示具体化（针对字符串类型的显示具体化）template<> class Point<char*, char*>{public:    Point(char *x, char *y): m_x(x), m_y(y){ }public:    char *getX() const{ return m_x; }    void setX(char *x){ m_x = x; }    char *getY() const{ return m_y; }    void setY(char *y){ m_y = y; }    void display() const;private:    char *m_x;  //x坐标    char *m_y;  //y坐标};//这里不能带模板头template<>void Point<char*, char*>::display() const{    cout<<"x="<<m_x<<" | y="<<m_y<<endl;}int main(){    ( new Point<int, int>(10, 20) ) -> display();    ( new Point<int, char*>(10, "东京180度") ) -> display();    ( new Point<char*, char*>("东京180度", "北纬210度") ) -> display();    return 0;}
```

运行结果：
x=10, y=20
x=10, y=东京180度
x=东京180度 | y=北纬210度

请读者注意第 25 行代码，`Point<char*, char*>`表明了要将类型参数 T1、T2 都具体化为`char*`类型，原来使用 T1、T2 的位置都应该使用`char*`替换。Point 类有两个类型参数 T1、T2，并且都已经被具体化了，所以整个类模板就不再有类型参数了，模板头应该写作`template<>`。

再来对比第 19、40 行代码，可以发现，当在类的外部定义成员函数时，普通类模板的成员函数前面要带上模板头，而具体化的类模板的成员函数前面不能带模板头。

### 部分显式具体化

在上面的显式具体化例子中，我们为所有的类型参数都提供了实参，所以最后的模板头为空，也即`template<>`。另外 C++ 还允许只为一部分类型参数提供实参，这称为部分显式具体化。

部分显式具体化只能用于类模板，不能用于函数模板。

仍然以 Point 为例，假设我现在希望“只要横坐标 x 是字符串类型”就以`|`来分隔输出结果，而不管纵坐标 y 是什么类型，这种要求就可以使用部分显式具体化技术来满足。请看下面的代码：

```c++
#include <iostream>using namespace std;//类模板template<class T1, class T2> class Point{public:    Point(T1 x, T2 y): m_x(x), m_y(y){ }public:    T1 getX() const{ return m_x; }    void setX(T1 x){ m_x = x; }    T2 getY() const{ return m_y; }    void setY(T2 y){ m_y = y; }    void display() const;private:    T1 m_x;    T2 m_y;};template<class T1, class T2>  //这里需要带上模板头void Point<T1, T2>::display() const{    cout<<"x="<<m_x<<", y="<<m_y<<endl;}//类模板的部分显示具体化template<typename T2> class Point<char*, T2>{public:    Point(char *x, T2 y): m_x(x), m_y(y){ }public:    char *getX() const{ return m_x; }    void setX(char *x){ m_x = x; }    T2 getY() const{ return m_y; }    void setY(T2 y){ m_y = y; }    void display() const;private:    char *m_x;  //x坐标    T2 m_y;  //y坐标};template<typename T2>  //这里需要带上模板头void Point<char*, T2>::display() const{    cout<<"x="<<m_x<<" | y="<<m_y<<endl;}int main(){    ( new Point<int, int>(10, 20) ) -> display();    ( new Point<char*, int>("东京180度", 10) ) -> display();    ( new Point<char*, char*>("东京180度", "北纬210度") ) -> display();    return 0;}
```

运行结果：
x=10, y=20
x=东京180度 | y=10
x=东京180度 | y=北纬210度

本例中，T1 对应横坐标 x 的类型，我们将 T1 具体化为`char*`，第 25 行代码就是类模板的部分显示具体化。

模板头`template<typename T2>`中声明的是没有被具体化的类型参数；类名`Point<char*, T2>`列出了所有类型参数，包括未被具体化的和已经被具体化的。

类名后面之所以要列出所有的类型参数，是为了让编译器确认“到底是第几个类型参数被具体化了”，如果写作`template<typename T2> class Point<char*>`，编译器就不知道char*代表的是第一个类型参数，还是第二个类型参数。

## 7.7 C++模板中的非类型参数

模板是一种泛型技术，目的是将数据的类型参数化，以增强 C++ 语言（强类型语言）的灵活性。C++ 对模板的支持非常自由，模板中除了可以包含类型参数，还可以包含非类型参数，例如：

```c++
template<typename T, int N> class Demo{ };template<class T, int N> void func(T (&arr)[N]);
```

T 是一个类型参数，它通过`class`或`typename`关键字指定。N 是一个非类型参数，用来传递数据的值，而不是类型，它和普通函数的形参一样，都需要指明具体的类型。类型参数和非类型参数都可以用在函数体或者类体中。

当调用一个函数模板或者通过一个类模板创建对象时，非类型参数会被用户提供的、或者编译器推断出的值所取代。

### 在函数模板中使用非类型参数

在《[C++函数模板的重载](http://c.biancheng.net/view/vip_2320.html)》一节中，我们通过 Swap() 函数来交换两个数组的值，其原型为：

```c++
template<typename T> void Swap(T a[], T b[], int len);
```

形参 len 用来指明要交换的数组的长度，调用 Swap() 函数之前必须先通过`sizeof`求得数组长度再传递给它。

有读者可能会疑惑，为什么在函数内部不能求得数组长度，一定要通过形参把数组长度传递进去呢？这是因为数组在作为函数参数时会自动转换为数组指针，而`sizeof`只能通过数组名求得数组长度，不能通过数组指针求得数组长度，这在《[数组和指针绝不等价，数组是另外一种类型](http://c.biancheng.net/view/vip_2018.html)》《[数组到底在什么时候会转换为指针](http://c.biancheng.net/view/vip_2019.html)》两节中已经作了详细讲解。

多出来的形参 len 给编码带来了不便，我们可以借助模板中的非类型参数将它消除，请看下面的代码：

```c++
template<typename T, unsigned N> void Swap(T (&a)[N], T (&b)[N]){    T temp;    for(int i=0; i<N; i++){        temp = a[i];        a[i] = b[i];        b[i] = temp;    }}
```

`T (&a)[N]`表明 a 是一个引用，它引用的数据的类型是`T [N]`，也即一个数组；`T (&b)[N]`也是类似的道理。分析一个引用和分析一个指针的方法类似，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析，这一点已在《[只需一招，彻底攻克C语言指针](http://c.biancheng.net/view/vip_2024.html)》中进行了讲解。

调用 Swap() 函数时，需要将数组名字传递给它：

```c++
int a[5] = { 1, 2, 3, 4, 5 };int b[5] = { 10, 20, 30, 40, 50 };Swap(a, b);
```

编译器会使用数组类型`int`来代替类型参数`T`，使用数组长度`5`来代替非类型参数`N`。

下面是一个完整的示例：

```c++
#include <iostream>using namespace std;template<class T> void Swap(T &a, T &b);  //模板①：交换基本类型的值template<typename T, unsigned N> void Swap(T (&a)[N], T (&b)[N]);  //模板②：交换两个数组template<typename T, unsigned N> void printArray(T (&arr)[N]);  //打印数组元素int main(){    //交换基本类型的值    int m = 10, n = 99;    Swap(m, n);  //匹配模板①    cout<<m<<", "<<n<<endl;    //交换两个数组    int a[5] = { 1, 2, 3, 4, 5 };    int b[5] = { 10, 20, 30, 40, 50 };    Swap(a, b);  //匹配模板②    printArray(a);    printArray(b);    return 0;}template<class T> void Swap(T &a, T &b){    T temp = a;    a = b;    b = temp;}template<typename T, unsigned N> void Swap(T (&a)[N], T (&b)[N]){    T temp;    for(int i=0; i<N; i++){        temp = a[i];        a[i] = b[i];        b[i] = temp;    }}template<typename T, unsigned N> void printArray(T (&arr)[N]){    for(int i=0; i<N; i++){        if(i == N-1){            cout<<arr[i]<<endl;        }else{            cout<<arr[i]<<", ";        }    }}
```

运行结果：
99, 10
10, 20, 30, 40, 50
1, 2, 3, 4, 5

printArray() 也使用了非类型参数，这样只传递数组名字就能够打印数组元素了。

### 在类模板中使用非类型参数

C/C++ 规定，数组一旦定义后，它的长度就不能改变了；换句话说，数组容量不能动态地增大或者减小。这样的数组称为静态数组（Static array）。静态数组有时候会给编码代码不便，我们可以通过自定义的 Array 类来实现动态数组（Dynamic array）。所谓动态数组，是指数组容量能够在使用的过程中随时增大或减小。

动态数组的完整实现代码如下：

```c++
#include <iostream>#include <cstring>#include <cstdlib>using namespace std;template<typename T, int N>class Array{public:    Array();    ~Array();public:    T & operator[](int i);  //重载下标运算符[]    int length() const { return m_length; }  //获取数组长度    bool capacity(int n);  //改变数组容量private:    int m_length;  //数组的当前长度    int m_capacity;  //当前内存的容量（能容乃的元素的个数）    T *m_p;  //指向数组内存的指针};template<typename T, int N>Array<T, N>::Array(){    m_p = new T[N];    m_capacity = m_length = N;}template<typename T, int N>Array<T, N>::~Array(){    delete[] m_p;}template<typename T, int N>T & Array<T, N>::operator[](int i){    if(i<0 || i>=m_length){        cout<<"Exception: Array index out of bounds!"<<endl;    }    return m_p[i];}template<typename T, int N>bool Array<T, N>::capacity(int n){    if(n > 0){  //增大数组        int len = m_length + n;  //增大后的数组长度        if(len <= m_capacity){  //现有内存足以容纳增大后的数组            m_length = len;            return true;        }else{  //现有内存不能容纳增大后的数组            T *pTemp = new T[m_length + 2 * n * sizeof(T)];  //增加的内存足以容纳 2*n 个元素            if(pTemp == NULL){  //内存分配失败                cout<<"Exception: Failed to allocate memory!"<<endl;                return false;            }else{  //内存分配成功                memcpy( pTemp, m_p, m_length*sizeof(T) );                delete[] m_p;                m_p = pTemp;                m_capacity = m_length = len;            }        }    }else{  //收缩数组        int len = m_length - abs(n);  //收缩后的数组长度        if(len < 0){            cout<<"Exception: Array length is too small!"<<endl;            return false;        }else{            m_length = len;            return true;        }    }}int main(){    Array<int, 5> arr;    //为数组元素赋值    for(int i=0, len=arr.length(); i<len; i++){        arr[i] = 2*i;    }       //第一次打印数组    for(int i=0, len=arr.length(); i<len; i++){        cout<<arr[i]<<" ";    }    cout<<endl;       //扩大容量并为增加的元素赋值    arr.capacity(8);    for(int i=5, len=arr.length(); i<len; i++){        arr[i] = 2*i;    }    //第二次打印数组    for(int i=0, len=arr.length(); i<len; i++){        cout<<arr[i]<<" ";    }    cout<<endl;    //收缩容量    arr.capacity(-4);    //第三次打印数组    for(int i=0, len=arr.length(); i<len; i++){        cout<<arr[i]<<" ";    }    cout<<endl;    return 0;}
```

运行结果：
0 2 4 6 8
0 2 4 6 8 10 12 14 16 18 20 22 24
0 2 4 6 8 10 12 14 16

Array 是一个类模板，它有一个类型参数`T`和一个非类型参数`N`，T 指明了数组元素的类型，N 指明了数组长度。

capacity() 成员函数是 Array 类的关键，它使得数组容量可以动态地增加或者减小。传递给它一个正数时，数组容量增大；传递给它一个负数时，数组容量减小。

之所以能通过`[ ]`来访问数组元素，是因为在 Array 类中以成员函数的形式重载了`[ ]`运算符，并且返回值是数组元素的引用。如果直接返回数组元素的值，那么将无法给数组元素赋值。

### 非类型参数的限制

非类型参数的类型不能随意指定，它受到了严格的限制，只能是一个整数，或者是一个指向对象或函数的指针（也可以是引用）。引用和指针在本质上是一样的，我们已在《[引用在本质上是什么，它和指针到底有什么区别](http://c.biancheng.net/view/vip_2252.html)》中讲到。

\1) 当非类型参数是一个整数时，传递给它的实参，或者由编译器推导出的实参必须是一个常量表达式，例如`10`、`2 * 30`、`18 + 23 - 4`等，但不能是`n`、`n + 10`、`n + m`等（n 和 m 都是变量）。

对于上面的 Swap() 函数，下面的调用就是错误的：

```c++
int len;cin>>len;int a[len];int b[len];Swap(a, b);
```

对上面的 Array 类，以下创建对象的方式是错误的：

```c++
int len;cin>>len;Array<int, len> arr;
```

这两种情况，编译器推导出来的实参是 len，是一个变量，而不是常量。

\2) 当非类型参数是一个指针（引用）时，绑定到该指针的实参必须具有静态的生存期；换句话说，实参必须存储在虚拟地址空间中的静态数据区。局部变量位于栈区，动态创建的对象位于堆区，它们都不能用作实参。

## 7.8 C++模板的实例化

模板（Templet）并不是真正的函数或类，它仅仅是编译器用来生成函数或类的一张“图纸”。模板不会占用内存，最终生成的函数或者类才会占用内存。由模板生成函数或类的过程叫做模板的实例化（Instantiate），相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个实例（Instantiation）。

在学习模板以前，如果想针对不同的类型使用相同的算法，就必须定义多个极其相似的函数或类，这样不但做了很多重复性的工作，还导致代码维护困难，用于交换两个变量的值的 [Swap() 函数](http://c.biancheng.net/view/2206.html)就是一个典型的代表。而有了模板后，这些工作都可以交给编译器了，编译器会帮助我们自动地生成这些代码。从这个角度理解，模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码。

模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码。也就是说，编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次。实例化的过程也很简单，就是将所有的类型参数用实参代替。

例如，给定下面的函数模板和函数调用：

```c++
template<typename T> void Swap(T &a, T &b){    T temp = a;    a = b;    b = temp;}int main(){    int n1 = 100, n2 = 200, n3 = 300, n4 = 400;    float f1 = 12.5, f2 = 56.93;       Swap(n1, n2);  //T为int，实例化出 void Swap(int &a, int &b);    Swap(f1, f2);  //T为float，实例化出 void Swap(float &a, float &b);    Swap(n3, n4);  //T为int，调用刚才生成的 void Swap(int &a, int &b);    return 0;}
```

编译器会根据不同的实参实例化出不同版本的 Swap() 函数。对于`Swap(n1, n2)`调用，编译器会生成并编译一个 Swap() 版本，其中 T 被替换为 int：

```c++
void Swap(int &a, int &b){    int temp = a;    a = b;    b = temp;}
```

对于`Swap(f1, f2)`调用，编译器会生成另一个 Swap() 版本，其中 T 被替换为 float。对于`Swap(n3, n4)`调用，编译器不会再生成新版本的 Swap() 了，因为刚才已经针对 int 生成了一个版本，直接拿来使用即可。

另外需要注意的是类模板的实例化，通过类模板创建对象时并不会实例化所有的成员函数，只有等到真正调用它们时才会被实例化；如果一个成员函数永远不会被调用，那它就永远不会被实例化。这说明类的实例化是延迟的、局部的，编译器并不着急生成所有的代码。

通过类模板创建对象时，一般只需要实例化成员变量和构造函数。成员变量被实例化后就能够知道对象的大小了（占用的字节数），构造函数被实例化后就能够知道如何初始化了；对象的创建过程就是分配一块大小已知的内存，并对这块内存进行初始化。

请看下面的例子：

```c++
#include <iostream>using namespace std;template<class T1, class T2>class Point{public:    Point(T1 x, T2 y): m_x(x), m_y(y){ }public:    T1 getX() const{ return m_x; }    void setX(T1 x){ m_x = x; }    T2 getY() const{ return m_y; };    void setY(T2 y){ m_y = y; };    void display() const;private:    T1 m_x;    T2 m_y;};template<class T1, class T2>void Point<T1, T2>::display() const{    cout<<"x="<<m_x<<", y="<<m_y<<endl;}int main(){    Point<int, int> p1(10, 20);    p1.setX(40);    p1.setY(50);    cout<<"x="<<p1.getX()<<", y="<<p1.getY()<<endl;    Point<char*, char*> p2("东京180度", "北纬210度");    p2.display();    return 0;}
```

运行结果：
x=40, y=50
x=东京180度, y=北纬210度

p1 调用了所有的成员函数，整个类会被完整地实例化。p2 只调用了构造函数和 display() 函数，剩下的 get 函数和 set 函数不会被实例化。

值得提醒的是，`Point<int, int>`和`Point<char*, char*>`是两个相互独立的类，它们的类型是不同的，不能相互兼容，也不能自动地转换类型，所以诸如`p1 = p2;`这样的语句是错误的，除非重载了`=`运算符。

## 7.9 将C++模板应用于多文件编程

在将函数应用于多文件编程时，我们通常是将函数定义放在源文件（`.cpp`文件）中，将函数声明放在头文件（`.h`文件）中，使用函数时引入（`#include`命令）对应的头文件即可。

编译是针对单个源文件的，只要有函数声明，编译器就能知道函数调用是否正确；而将函数调用和函数定义对应起来的过程，可以延迟到链接时期。正是有了链接器的存在，函数声明和函数定义的分离才得以实现。

将类应用于多文件编程也是类似的道理，我们可以将类的声明和类的实现分别放到头文件和源文件中。类的声明已经包含了所有成员变量的定义和所有成员函数的声明（也可以是 inline 形式的定义），这样就知道如何创建对象了，也知道如何调用成员函数了，只是还不能将函数调用与函数实现对应起来，但是这又有什么关系呢，反正链接器可以帮助我们完成这项工作。

总起来说，不管是函数还是类，声明和定义（实现）的分离其实是一回事，都是将函数定义放到其他文件中，最终要解决的问题也只有一个，就是把函数调用和函数定义对应起来（找到函数定义的地址，并填充到函数调用处），而保证完成这项工作的就是链接器。

基于传统的编程思维，初学者往往也会将模板（函数模板和类模板）的声明和定义分散到不同的文件中，以期达到「模块化编程」的目的。但事实证明这种做法是不对的，程序员惯用的做法是将模板的声明和定义都放到头文件中。

模板并不是真正的函数或类，它仅仅是用来生成函数或类的一张“图纸”，在这个生成过程中有三点需要明确：

- 模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码；
- 模板的实例化是由编译器完成的，而不是由链接器完成的；
- 在实例化过程中需要知道模板的所有细节，包含声明和定义。

### 将函数模板的声明和定义分散到不同的文件

为了更加深入地说明问题，现在有一个反面教材，它将函数模板的声明和实现分别放到了头文件和源文件。

func.cpp 源码：

```c++
//交换两个数的值template<typename T> void Swap(T &a, T &b){    T temp = a;    a = b;    b = temp;}//冒泡排序算法void bubble_sort(int arr[], int n){    for(int i=0; i<n-1; i++){        bool isSorted = true;        for(int j=0; j<n-1-i; j++){            if(arr[j] > arr[j+1]){                isSorted = false;                Swap(arr[j], arr[j+1]);  //调用Swap()函数            }        }        if(isSorted) break;    }}
```

func.h 源码：

```c++
#ifndef _FUNC_H#define _FUNC_Htemplate<typename T> void Swap(T &a, T &b);void bubble_sort(int arr[], int n);#endif
```

main.cpp 源码

```c++
#include <iostream>#include "func.h"using namespace std;int main(){    int n1 = 10, n2 = 20;    Swap(n1, n2);       double f1 = 23.8, f2 = 92.6;    Swap(f1, f2);    return 0;}
```

该工程包含了两个源文件和一个头文件，`func.cpp`中定义了两个函数，`func.h`中对函数进行了声明，`main.cpp`中对函数进行了调用，这是典型的将函数的声明和实现分离的编程模式。

运行上面的程序，会产生一个链接错误，意思是无法找到`void Swap<double>(double &, double &)`这个函数。主函数 main() 中共调用了两个版本的 Swap() 函数，它们的原型分别是：

```c++
void Swap<double>(int &, int &);void Swap<double>(double &, double &);
```

为什么针对 int 的版本能够找到定义，而针对 double 的版本就找不到呢？

我们先来说针对 double 的版本为什么找不到定义。当编译器编译`main.cpp`时，发现使用到了 double 版本的 Swap() 函数，于是尝试生成一个 double 版本的实例，但是由于只有声明没有定义，所以生成失败。不过这个时候编译器不会报错，而是对该函数的调用做一个记录，希望等到链接程序时在其他目标文件（.obj 文件或 .o 文件）中找到该函数的定义。很明显，本例需要到`func.obj`中寻找。但是遗憾的是，`func.cpp`中没有调用 double 版本的 Swap() 函数，编译器不会生成 double 版本的实例，所以链接器最终也找不到 double 版本的函数定义，只能抛出一个链接错误，让程序员修改代码。

那么，针对 int 的版本为什么能够找到定义呢？请读者注意`bubble_sort()`函数，该函数用来对数组元素进行排序，在排序过程中需要频繁的交换两个元素的值，所以调用了 Swap() 函数，这样做的结果是：编译生成的`func.obj`中会有一个 int 版本的 Swap() 函数定义。编译器在编译`main.cpp`时虽然找不到 int 版本的实例，但是等到链接程序时，链接器在`func.obj`中找到了，所以针对 int 版本的调用就不会出错。

### 将类模板的声明和实现分散到不同的文件

我们再看一个类模板的反面教材，它将类模板的声明和实现分别放到了头文件和源文件。

point.h 源码：

```c++
#ifndef _POINT_H#define _POINT_Htemplate<class T1, class T2>class Point{public:    Point(T1 x, T2 y): m_x(x), m_y(y){ }public:    T1 getX() const{ return m_x; }    void setX(T1 x){ m_x = x; }    T2 getY() const{ return m_y; };    void setY(T2 y){ m_y = y; };    void display() const;private:    T1 m_x;    T2 m_y;};#endif
```

point.cpp 源码：

```c++
#include <iostream>#include "point.h"using namespace std;template<class T1, class T2>void Point<T1, T2>::display() const{    cout<<"x="<<m_x<<", y="<<m_y<<endl;}
```

main.cpp 源码：

```c++
#include <iostream>#include "point.h"using namespace std;int main(){    Point<int, int> p1(10, 20);    p1.setX(40);    p1.setY(50);    cout<<"x="<<p1.getX()<<", y="<<p1.getY()<<endl;    Point<char*, char*> p2("东京180度", "北纬210度");    p2.display();    return 0;}
```

该工程包含了两个源文件和一个头文件，`point.h`中声明了类模板，`point.cpp`中对类模板进行了实现，`main.cpp`中通过类模板创建了对象，并调用了成员函数，这是典型的将类的声明和实现分离的编程模式。

运行上面的程序，会产生一个链接错误，意思是无法通过 p2 调用`Point<char*, char*>::display() const`这个函数。

类模板声明位于`point.h`中，它包含了所有成员变量的定义以及构造函数、get 函数、set 函数的定义，这些信息足够创建出一个完整的对象了，并且可以通过对象调用 get 函数和 set 函数，所以`main.cpp`的前 11 行代码都不会报错。而第 12 行代码调用了 display() 函数，该函数的定义位于`point.cpp`文件中，并且`point.cpp`中也没有生成对应的实例，所以会在链接期间抛出错误。

### 总结

通过上面的两个反面教材可以总结出，「不能将模板的声明和定义分散到多个文件中」的根本原因是：模板的实例化是由编译器完成的，而不是由链接器完成的，这可能会导致在链接期间找不到对应的实例。

修复上面两个项目的方法也很简单，就是将 func.cpp、point.cpp 的模板定义（实现）部分分别合并到 func.h、point.h 中。由于篇幅限制，这里不再给出具体的代码了，请读者到百度网盘下载正确的代码：

- 下载地址：https://pan.baidu.com/s/1eRO1AKE
- 提取密码：yp3u

## 7.10 C++模板的显式实例化

前面讲到的模板的实例化是在调用函数或者创建对象时由编译器自动完成的，不需要程序员引导，因此称为隐式实例化。相对应的，我们也可以通过代码明确地告诉编译器需要针对哪个类型进行实例化，这称为显式实例化。

编译器在实例化的过程中需要知道模板的所有细节：对于函数模板，也就是函数定义；对于类模板，需要同时知道类声明和类定义。我们必须将显式实例化的代码放在包含了模板定义的源文件中，而不是仅仅包含了模板声明的头文件中。

显式实例化的一个好处是，可以将模板的声明和定义（实现）分散到不同的文件中了。

### 函数模板的显式实例化

以上节讲到的 compare() 函数为例，针对 double 类型的显式实例化代码为：

```c++
template void Swap(double &a, double &b);
```

这条语言由两部分组成，前边是一个`template`关键字（后面不带`< >`），后面是一个普通的函数原型，组合在一起的意思是：将模板实例化成和函数原型对应的一个具体版本。

将该代码放到 func.cpp 文件的最后，再运行程序就不会出错了。

另外，还可以在包含了函数调用的源文件（main.cpp）中再增加下面的一条语句：

```c++
extern template void Swap(double &a, double &b);
```

该语句在前面增加了`extern`关键字，它的作用是明确地告诉编译器，该版本的函数实例在其他文件中，请在链接期间查找。不过这条语句是多余的，即使不写，编译器发现当前文件中没有对应的模板定义，也会自动去其他文件中查找。

上节我们展示了一个反面教材，告诉大家不能把函数模板的声明和定义分散到不同的文件中，但是现在有了显式实例化，这一点就可以做到了，下面就对上节的代码进行修复。

func.cpp 源码：

```c++
//交换两个数的值template<typename T> void Swap(T &a, T &b){    T temp = a;    a = b;    b = temp;}//冒泡排序算法void bubble_sort(int arr[], int n){    for(int i=0; i<n-1; i++){        bool isSorted = true;        for(int j=0; j<n-1-i; j++){            if(arr[j] > arr[j+1]){                isSorted = false;                Swap(arr[j], arr[j+1]);  //调用Swap()函数            }        }        if(isSorted) break;    }}template void Swap(double &a, double &b);  //显式实例化定义 
```

func.h 源码：

```c++
#ifndef _FUNC_H#define _FUNC_Htemplate<typename T> void Swap(T &a, T &b);void bubble_sort(int arr[], int n);#endif
```

main.cpp 源码：

```c++
#include <iostream>#include "func.h"using namespace std;//显示实例化声明（也可以不写）extern template void Swap(double &a, double &b);extern template void Swap(int &a, int &b);int main(){    int n1 = 10, n2 = 20;    Swap(n1, n2);      double f1 = 23.8, f2 = 92.6;    Swap(f1, f2);    return 0;}
```

显式实例化也包括声明和定义，定义要放在模板定义（实现）所在的源文件，声明要放在模板声明所在的头文件（当然也可以不写）。

### 类模板的显式实例化

类模板的显式实例化和函数模板类似。以上节的 Point 类为例，针对`char*`类型的显式实例化（定义形式）代码为：

```c++
template class Point<char*, char*>;
```

相应地，它的声明形式为：

```c++
extern template class Point<char*, char*>;
```

不管是声明还是定义，都要带上`class`关键字，以表明这是针对类模板的。

另外需要注意的是，显式实例化一个类模板时，会一次性实例化该类的所有成员，包括成员变量和成员函数。

有了类模板的显式实例化，就可以将类模板的声明和定义分散到不同的文件中了，下面我们就来修复上节的代码。

point.cpp 源文件：

```c++
#include <iostream>#include "point.h"using namespace std;template<class T1, class T2>void Point<T1, T2>::display() const{    cout<<"x="<<m_x<<", y="<<m_y<<endl;}//显式实例化定义template class Point<char*, char*>;template class Point<int, int>;
```

point.h 源码：

```c++
#ifndef _POINT_H#define _POINT_Htemplate<class T1, class T2>class Point{public:    Point(T1 x, T2 y): m_x(x), m_y(y){ }public:    T1 getX() const{ return m_x; }    void setX(T1 x){ m_x = x; }    T2 getY() const{ return m_y; };    void setY(T2 y){ m_y = y; };    void display() const;private:    T1 m_x;    T2 m_y;};#endif
```

main.cpp 源码：

```c++
#include <iostream>#include "point.h"using namespace std;//显式实例化声明（也可以不写）extern template class Point<char*, char*>;extern template class Point<int, int>;int main(){    Point<int, int> p1(10, 20);    p1.setX(40);    p1.setY(50);    cout<<"x="<<p1.getX()<<", y="<<p1.getY()<<endl;    Point<char*, char*> p2("东京180度", "北纬210度");    p2.display();    return 0;}
```

### 总结

函数模板和类模板的实例化语法是类似的，我们不妨对它们做一下总结：

```c++
extern template declaration;  //实例化声明template declaration;  //实例化定义
```

对于函数模板来说，declaration 就是一个函数原型；对于类模板来说，declaration 就是一个类声明。

### 显式实例化的缺陷

C++ 支持显式实例化的目的是为「模块化编程」提供一种解决方案，这种方案虽然有效，但是也有明显的缺陷：程序员必须要在模板的定义文件（实现文件）中对所有使用到的类型进行实例化。这就意味着，每次更改了模板使用文件（调用函数模板的文件，或者通过类模板创建对象的文件），也要相应地更改模板定义文件，以增加对新类型的实例化，或者删除无用类型的实例化。

一个模板可能会在多个文件中使用到，要保持这些文件的同步更新是非常困难的。而对于库的开发者来说，他不能提前假设用户会使用哪些类型，所以根本就无法使用显式实例化，只能将模板的声明和定义（实现）全部放到头文件中；C++ 标准库几乎都是用模板来实现的，这些模板的代码也都位于头文件中。

总起来说，如果我们开发的模板只有我们自己使用，那也可以勉强使用显式实例化；如果希望让其他人使用（例如库、组件等），那只能将模板的声明和定义都放到头文件中了。

## 7.11 C++类模板与继承详解

类模板和类模板之间、类模板和类之间可以互相继承。它们之间的派生关系有以下四种情况。

### 1. 类模板从类模板派生

示例程序：

```c++
template <class T1, class T2>class A{    Tl v1; T2 v2;};template <class T1, class T2>class B : public A <T2, T1>{    T1 v3; T2 v4;};template <class T>class C : public B <T, T>{    T v5;};int main(){    B<int, double> obj1;    C<int> obj2;    return 0;}
```

编译到第 18 行，编译器用 int 替换类模板 B 中的 T1，用 double 替换 T2，生成 B<int, double> 类如下：

```c++
class B <int, double>: public A <double, int>{    int v3; double v4;};
```

B <int, double> 的基类是 A <double, int>。于是编译器就要用 double 替换类模板 A 中的 T1，用 int 替换 T2，生成 A<double, int> 类如下：

```c++
class A <double, int>{    double v1; int v2;};
```

编译到第 19 行，编译器生成类 C<int>，还有 C<int> 的直接基类 B<int, int>，以及 B<int, int> 的基类 A<int, int>。

### 2. 类模板从模板类派生

示例程序：

```c++
template<class T1, class T2>class A{ T1 v1; T2 v2; };template <class T>class B: public A <int, double>{T v;};int main() { B <char> obj1; return 0; }
```

第 4 行，A<int, double> 是一个具体的类的名字，而且它是一个模板类，因此说类模板 B 是从模板类派生而来的。

编译器编译到第 5 行`B<Char>obj1;`时会自动生成两个模板类：A<int, double> 和 B<char>。

### 3. 类模板从普通类派生

示例程序：

```c++
class A{ int v1; };template<class T>class B: public A{ T v; };int main (){ B <char> obj1; return 0; }
```

### 4. 普通类从模板类派生

示例程序：

```c++
template <class T>class A{ T v1; int n; };class B: public A <int> { double v; };int main() { B obj1; return 0; }
```

## 7.12 C++类模板与友元详解

下面我们分四种情况分别讨论。

### 1. 函数、类、类的成员函数作为类模板的友元

函数、类、类的成员函数都可以作为类模板的友元。程序示例如下：

```c++
void Func1() {  }class A {  };class B{public:    void Func() { }};template <class T>class Tmpl{    friend void Func1();    friend class A;    friend void B::Func();};int main(){    Tmpl<int> i;    Tmpl<double> f;    return 0;}
```

类模板实例化时，除了类型参数被替换外，其他所有内容都原样保留，因此任何从 Tmp1 实例化得到的类都包含上面三条友元声明，因而也都会把 Func1、类 A 和 B::Func 当作友元。

### 2. 函数模板作为类模板的友元

例题：在《[C++类模板（模板类）](http://c.biancheng.net/view/2318.html)》一节中我们定义了 Pair 模板，将`<<`运算符重载为一个函数模板，并将该函数模板作为 Pair 模板的友元，这样，任何从 Pair 模板实例化得到的对象都能用`<<`运算符通过 cout 输出。

程序代码如下（函数模板作为类模板的友元）：

```c++
#include <iostream>#include <string>using namespace std;template <class T1, class T2>class Pair{private:    T1 key;  //关键字    T2 value;  //值public:    Pair(T1 k, T2 v) : key(k), value(v) { };    bool operator < (const Pair<T1, T2> & p) const;    template <class T3, class T4>    friend ostream & operator << (ostream & o, const Pair<T3, T4> & p);};template <class T1, class T2>bool Pair <T1, T2>::operator< (const Pair<T1, T2> & p) const{  //“小”的意思就是关键字小    return key < p.key;}template <class Tl, class T2>ostream & operator << (ostream & o, const Pair<T1, T2> & p){    o << "(" << p.key << "," << p.value << ")";    return o;}int main(){    Pair<string, int> student("Tom", 29);    Pair<int, double> obj(12, 3.14);    cout << student << " " << obj;    return 0;}
```

程序的输出结果是：
(Torn, 29) (12, 3.14)

第 13、14 行将函数模板 operator<< 声明为类模板 Pair 的友元。在 Visual Studio 中，这两行也可以用下面的写法替代：

```c++
friend ostream & operator<< <T1, T2>(ostream & o, const Pair<T1, T2> & p);
```

但在 Dev C ++ 中，替代后编译就无法通过了。

编译本程序时，编译器自动生成了两个 operator << 函数，它们的原型分别是：

```c++
ostream & operator << (ostream & o, const Pair<string, int> & p);ostream & operator << (ostream & o, const Pair<int, double> & p);
```

前者是 Pair <string, int> 类的友元，但不是 Pair<int, double> 类的友元；后者是 Pair<int, double> 类的友元，但不是 Pair<string, int> 类的友元。

### 3. 函数模板作为类的友元

实际上，类也可以将函数模板声明为友元。程序示例如下：

```c++
#include <iostream>using namespace std;class A{    int v;public:    A(int n) :v(n) { }    template <class T>    friend void Print(const T & p);};template <class T>void Print(const T & p){    cout << p.v;}int main(){    A a(4);    Print(a);    return 0;}
```

程序的输出结果是：
4

编译器编译到第 19 行`Print(a);`时，就从 Print 模板实例化出一个 Print 函数，原型如下：

```c++
void Print(const A & p);
```

这个函数本来不能访问 p 的私有成员。但是编译器发现，如果将类 A 的友元声明中的 T 换成 A，就能起到将该 Print 函数声明为友元的作用，因此编译器就认为该 Print 函数是类 A 的友元。

思考题：类还可以将类模板或类模板的成员函数声明为友元。自行研究这两种情况该怎么写。

### 4. 类模板作为类模板的友元

一个类模板还可以将另一个类模板声明为友元。程序示例如下：

```c++
#include <iostream>using namespace std;template<class T>class A{public:    void Func(const T & p)    {        cout << p.v;    }};template <class T>class B{private:    T v;public:    B(T n) : v(n) { }    template <class T2>    friend class A;  //把类模板A声明为友元};int main(){    B<int> b(5);    A< B<int> > a;  //用B<int>替换A模板中的 T    a.Func(b);    return 0;}
```

程序的输出结果是：
5

在本程序中，A< B<int> > 类成为 B<int> 类的友元。

## 7.13 C++类模板中的静态成员

类模板中可以定义静态成员，从该类模板实例化得到的所有类都包含同样的静态成员。

程序示例如下：

```c++
#include <iostream>using namespace std;template <class T>class A{private:    static int count;public:    A() { count ++; }    ~A() { count -- ; };    A(A &) { count ++ ; }    static void PrintCount() { cout << count << endl; }};template<> int A<int>::count = 0;template<> int A<double>::count = 0;int main(){    A<int> ia;    A<double> da;    ia.PrintCount();    da.PrintCount();    return 0;}
```

程序的输出结果是：
1
1

第 14 行和第 15 行，对静态成员变量在类外部加以声明是必需的。在 Visual Studio 2008 中，这两行也可以简单地写成：

```c++
int A<int>::count = 0;int A<double>::count = 0;
```

A<int> 和 A<double> 是两个不同的类。虽然它们都有静态成员变量 count，但是显然，A<int> 的对象 ia 和 A<double> 的对象 da 不会共享一份 count。

## 8 C++异常

## 9 面向对象进阶

## 10 输入输出流

## 11 文件操作

为了方便用户实现文件操作，C++提供了 3 个文件流类，分别是 ofstream（实现写文件）、ifstream（实现读文件）以及 fstream（实现读写文件），它们统称为“文件流类”。

关于文件操作，虽然在 C++ 程序中可以继续沿用 C 语言的那套文件操作方式，但**更推荐使用适当的文件流类来读写文件**。

## 11.2 C++文件类（文件流类）及用法详解

《[C++输入输出流](http://c.biancheng.net/cplus/50/)》一章中讲过，重定向后的 cin 和 cout 可分别用于读取文件中的数据和向文件中写入数据。除此之外，C++ 标准库中还专门提供了 3 个类用于实现文件操作，它们统称为文件流类，这 3 个类分别为：

- ifstream：专用于从文件中读取数据；
- ofstream：专用于向文件中写入数据；
- fstream：既可用于从文件中读取数据，又可用于向文件中写入数据。

> 值得一提的是，这 3 个文件流类都位于 <fstream> 头文件中，因此在使用它们之前，程序中应先引入此头文件。

这 3 个文件流类的继承关系，如图 1 所示。



![img](http://c.biancheng.net/uploads/allimg/180904/1-1PZ4144930532.jpg)
图1：C++类库中的流类


可以看到，ifstream 类和 fstream 类是从 istream 类派生而来的，因此 ifstream 类拥有 istream 类的全部成员方法。同样地，ofstream 和 fstream 类也拥有 ostream 类的全部成员方法。这也就意味着，istream 和 ostream 类提供的供 cin 和 cout 调用的成员方法，也同样适用于文件流。并且这 3 个类中有些成员方法是相同的，比如 operator <<()、operator >>()、peek()、ignore()、getline()、get() 等。

值得一提的是，和 <iostream> 头文件中定义有 ostream 和 istream 类的对象 cin 和 cout 不同，<fstream> 头文件中并没有定义可直接使用的 fstream、ifstream 和 ofstream 类对象。因此，如果我们想使用该类操作文件，需要自己创建相应类的对象。

> 为什么 C++ 标准库不提供现成的类似 fin 或者 fout 的对象呢？其实很简单，文件输入流和输出流的输入输出设备是硬盘中的文件，硬盘上有很多文件，到底应该使用哪一个呢？所以，C++ 标准库就把创建文件流对象的任务交给用户了。

fstream 类拥有 ifstream 和 ofstream 类中所有的成员方法，表 2 罗列了 fstream 类一些常用的成员方法。



| 成员方法名        | 适用类对象                                                   | 功  能                                     |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------ |
| open()            | fstream ifstream ofstream                                    | 打开指定文件，使其与文件流对象相关联。     |
| is_open()         | 检查指定文件是否已打开。                                     |                                            |
| close()           | 关闭文件，切断和文件流对象的关联。                           |                                            |
| swap()            | 交换 2 个文件流对象。                                        |                                            |
| operator>>        | fstream ifstream                                             | 重载 >> 运算符，用于从指定文件中读取数据。 |
| gcount()          | 返回上次从文件流提取出的字符个数。该函数常和 get()、getline()、ignore()、peek()、read()、readsome()、putback() 和 unget() 联用。 |                                            |
| get()             | 从文件流中读取一个字符，同时该字符会从输入流中消失。         |                                            |
| getline(str,n,ch) | 从文件流中接收 n-1 个字符给 str 变量，当遇到指定 ch 字符时会停止读取，默认情况下 ch 为 '\0'。 |                                            |
| ignore(n,ch)      | 从文件流中逐个提取字符，但提取出的字符被忽略，不被使用，直至提取出 n 个字符，或者当前读取的字符为 ch。 |                                            |
| peek()            | 返回文件流中的第一个字符，但并不是提取该字符。               |                                            |
| putback(c)        | 将字符 c 置入文件流（缓冲区）。                              |                                            |
| operator<<        | fstream ofstream                                             | 重载 << 运算符，用于向文件中写入指定数据。 |
| put()             | 向指定文件流中写入单个字符。                                 |                                            |
| write()           | 向指定文件中写入字符串。                                     |                                            |
| tellp()           | 用于获取当前文件输出流指针的位置。                           |                                            |
| seekp()           | 设置输出文件输出流指针的位置。                               |                                            |
| flush()           | 刷新文件输出流缓冲区。                                       |                                            |
| good()            | fstream ofstream ifstream                                    | 操作成功，没有发生任何错误。               |
| eof()             | 到达输入末尾或文件尾。                                       |                                            |

> 表 2 中仅列举的了部分常用的成员方法，更详细的介绍，读者可查看 [C++标准库手册](http://www.cplusplus.com/reference/fstream/fstream/)。

这里就以 fstream 类举例，简单演示一下如何使用表 2 中的一些成员方法操作文件：

```c++
#include <iostream>#include <fstream>using namespace std;int main() {    const char *url ="http://c.biancheng.net/cplus/";    //创建一个 fstream 类对象    fstream fs;    //将 test.txt 文件和 fs 文件流关联    fs.open("test.txt", ios::out);    //向test.txt文件中写入 url 字符串    fs.write(url, 30);    fs.close();    return 0;}
```

执行程序，该程序同目录下会生成一个 test.txt 文件，该文件的内容为：

http://c.biancheng.net/cplus/

> 注意，初学者只需借助注释看懂程序执行流程即可，具体的代码实现不必深究，后续章节会做详细讲解。

值得一提的是，无论是读取文件中的数据，还是向文件中写入数据，最先要做的就是调用 open() 成员方法打开文件。同时在操作文件结束后，还必须要调用 close() 成员方法关闭文件。关于如何使用 open() 函数打开一个文件，下一节会做详细介绍。

## 11.3 C++ open 打开文件（含打开模式一览表）

在对文件进行读写操作之前，先要打开文件。打开文件有以下两个目的：

- 通过指定文件名，建立起文件和文件流对象的关联，以后要对文件进行操作时，就可以通过与之关联的流对象来进行。
- 指明文件的使用方式。使用方式有只读、只写、既读又写、在文件末尾添加数据、以文本方式使用、以二进制方式使用等多种。


打开文件可以通过以下两种方式进行：

- 调用流对象的 open 成员函数打开文件。
- 定义文件流对象时，通过构造函数打开文件。

### 使用 open 函数打开文件

先看第一种文件打开方式。以 ifstream 类为例，该类有一个 open 成员函数，其他两个文件流类也有同样的 open 成员函数：

```c++
void open(const char* szFileName, int mode)
```

第一个参数是指向文件名的[指针](http://c.biancheng.net/c/80/)，第二个参数是文件的打开模式标记。

文件的打开模式标记代表了文件的使用方式，这些标记可以单独使用，也可以组合使用。表 1 列出了各种模式标记单独使用时的作用，以及常见的两种模式标记组合的作用。



| 模式标记                          | 适用对象                  | 作用                                                         |
| --------------------------------- | ------------------------- | ------------------------------------------------------------ |
| ios::in                           | ifstream fstream          | 打开文件用于读取数据。 **如果文件不存在，则打开出错。**      |
| ios::out                          | ofstream fstream          | 打开文件用于写入数据。**如果文件不存在，则新建该文件**；如果文件原来就存在，则打开时清除原来的内容。 |
| ios::app                          | ofstream fstream          | 打开文件，用于在其尾部添加数据。**如果文件不存在，则新建该文件**。 |
| ios::ate                          | ifstream                  | **打开一个已有的文件，并将文件读指针指向文件末尾（读写指 的概念后面解释）。如果文件不存在，则打开出错。** |
| ios:: trunc                       | ofstream                  | 打开文件时会清空内部存储的所有数据，单独使用时与 ios::out 相同。 |
| ios::binary                       | ifstream ofstream fstream | 以二进制方式打开文件。若不指定此模式，则以文本模式打开。     |
| ios::in \| ios::out               | fstream                   | 打开已存在的文件，既可读取其内容，也可向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错。 |
| ios::in \| ios::out               | ofstream                  | 打开已存在的文件，可以向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错。 |
| ios::in \| ios::out \| ios::trunc | fstream                   | 打开文件，既可读取其内容，也可向其写入数据。如果文件本来就存在，则打开时清除原来的内容；如果文件不存在，则新建该文件。 |


ios::binary 可以和其他模式标记组合使用，例如：

- `ios::in | ios::binary`表示用二进制模式，以读取的方式打开文件。
- `ios::out | ios::binary`表示用二进制模式，以写入的方式打开文件。


文本方式与二进制方式打开文件的区别其实非常微小，我会在《[文件的文本打开方式和二进制打开方式的区别](http://c.biancheng.net/view/311.html)》一节中专门解释。一般来说，如果处理的是文本文件，那么用文本方式打开会方便一些。但其实任何文件都可以以二进制方式打开来读写。

在流对象上执行 open 成员函数，给出文件名和打开模式，就可以打开文件。判断文件打开是否成功，可以看“对象名”这个表达式的值是否为 true，如果为 true，则表示文件打开成功。

下面的程序演示了如何打开文件：

```c++
#include <iostream>#include <fstream>using namespace std;int main(){    ifstream inFile;    inFile.open("c:\\tmp\\test.txt", ios::in);    if (inFile)  //条件成立，则说明文件打开成功        inFile.close();    else        cout << "test.txt doesn't exist" << endl;    ofstream oFile;    oFile.open("test1.txt", ios::out);    if (!oFile)  //条件成立，则说明文件打开出错        cout << "error 1" << endl;    else        oFile.close();    oFile.open("tmp\\test2.txt", ios::out | ios::in);    if (oFile)  //条件成立，则说明文件打开成功        oFile.close();    else        cout << "error 2" << endl;    fstream ioFile;    ioFile.open("..\\test3.txt", ios::out | ios::in | ios::trunc);    if (!ioFile)        cout << "error 3" << endl;    else        ioFile.close();    return 0;}
```

调用 open 成员函数时，给出的文件名可以是全路径的，如第 7 行的`c:\\tmp\\test.txt`， 指明文件在 c 盘的 tmp 文件夹中；也可以只给出文件名，如第 13 行的`test1.txt`，这种情况下程序会在当前文件夹（也就是可执行程序所在的文件夹）中寻找要打开的文件。

第 18 行的`tmp\\test2.txt`给出的是相对路径，说明 test2.txt 位于当前文件夹的 tmp 子文件夹中。第 24 行的`..\\test3.txt`也是相对路径，代表上一层文件夹，此时要到当前文件夹的上一层文件夹中查找 test3.txt。此外，`..\\..\\test4.txt`、`..\\tmp\\test4.txt`等都是合法的带相对路径的文件名。

### 使用流类的构造函数打开文件

定义流对象时，在构造函数中给出文件名和打开模式也可以打开文件。以 ifstream 类为例，它有如下构造函数：

```c++
ifstream::ifstream (const char* szFileName, int mode = ios::in, int);
```

第一个参数是指向文件名的指针；第二个参数是打开文件的模式标记，默认值为`ios::in`; 第三个参数是整型的，也有默认值，一般极少使用。

在定义流对象时打开文件的示例程序如下（用流类的构造函数打开文件）：

```c++
#include <iostream>#include <fstream>using namespace std;int main(){    ifstream inFile("c:\\tmp\\test.txt", ios::in);    if (inFile)        inFile.close();    else        cout << "test.txt doesn't exist" << endl;    ofstream oFile("test1.txt", ios::out);    if (!oFile)        cout << "error 1";    else        oFile.close();    fstream oFile2("tmp\\test2.txt", ios::out | ios::in);    if (!oFile2)        cout << "error 2";    else        oFile.close();    return 0;}
```

> 注意，当不再对打开的文件进行任何操作时，应及时调用 close() 成员方法关闭文件。有关该方法的用法，后续会做详细讲解。

## 11.4 文本打开方式和二进制打开方式的区别是什么？

在学习了 C++ 文件流对象使用 open() 打开文件后，我们知道它的第二个参数是一个字符串，用来表示文件打开方式，即如果使用 ios::binary，则表示以二进制方式打开文件；反之，则以文本文件的方式打开文件。

### 文本文件和二进制文件的区别

根据我们以往的经验，文本文件通常用来保存肉眼可见的字符，比如 .txt文件、.c文件、.dat文件等，用文本编辑器打开这些文件，我们能够顺利看懂文件的内容。

二进制文件通常用来保存视频、图片、程序等不可阅读的内容，用文本编辑器打开这些文件，会看到一堆乱码，根本看不懂。

但是从物理上讲，二进制文件和字符文件并没有什么区别，它们都是以二进制的形式保存在磁盘上的数据。

我们之所以能看懂文本文件的内容，是因为文本文件中采用的是 ASCII、UTF-8、GBK 等字符编码，文本编辑器可以识别出这些编码格式，并将编码值转换成字符展示出来。

而二进制文件使用的是 mp4、gif、exe 等特殊编码格式，文本编辑器并不认识这些编码格式，只能按照字符编码格式胡乱解析，所以就成了一堆乱七八糟的字符，有的甚至都没见过。

如果我们新建一个 mp4 文件，给它写入一串字符，然后再用文本编辑器打开，你一样可以读得懂，有兴趣的读者可以自己试试。

总的来说，不同类型的文件有不同的编码格式，必须使用对应的程序（软件）才能正确解析，否则就是一堆乱码，或者无法使用。

### 两种打开方式的区别

文本方式和二进制方式并没有本质上的区别，只是对于换行符的处理不同。

在 UNIX/Linux 平台中，用文本方式或二进制方式打开文件没有任何区别，因为文本文件以 \n（ASCII 码为 0x0a）作为换行符号。

但在 Windows 平台上，文本文件以连在一起的 \r\n 作为换行符号。如果以文本方式打开文件，当读取文件时，程序会将文件中所有的 \r\n 转换成一个字符 \n。也就是说，如果文本文件中有连续的两个字符是 \r\n，则程序会丢弃前面的 \r，只读入 \n。

同样当写入文件时，程序会将 \n 转换成 \r\n 写入。也就是说，如果要写入的内容中有字符 \n，则在写入该字符前，程序会自动先写入一个 \r。

因此在 Windows 平台上，如果用文本方式打开二进制文件进行读写，读写的内容就可能和文件的内容有出入。

总的来说，Linux 平台使用哪种打开方式都行；Windows 平台上最好用 "ios::in | ios::out" 等打开文本文件，用 "ios::binary" 打开二进制文件。但无论哪种平台，用二进制方式打开文件总是最保险的。

## 11.5 C++ close()关闭文件方法详解

《[C++ open打开文件](http://c.biancheng.net/view/294.html)》一节中，详细介绍了文件流对象如何调用 open() 成员方法打开指定文件。相对应地，文件流对象还可以主动关闭先前打开的文件，即调用 close() 成员方法。

我们知道，调用 open() 方法打开文件，是文件流对象和文件之间建立关联的过程。那么，调用 close() 方法关闭已打开的文件，就可以理解为是切断文件流对象和文件之间的关联。注意，close() 方法的功能仅是切断文件流与文件之间的关联，该文件流并会被销毁，其后续还可用于关联其它的文件。

close() 方法的用法很简单，其语法格式如下：

```c++
void close( )
```

可以看到，该方法既不需要传递任何参数，也没有返回值。

举个例子：

```c++
#include <fstream>using namespace std;int main(){    const char *url="http://c.biancheng.net/cplus/";    ofstream outFile("url.txt", ios::out);    //向 url.txt 文件中写入字符串    outFile.write(url, 30);    //关闭已打开的文件    outFile.close();    return 0;}
```

运行程序，在该程序同目录下会生成一个 url.txt 文件，其内部存储的数据为：

http://c.biancheng.net/cplus/

有些读者可能发现，即便上面程序中不调用 close() 方法，也能成功向 url.txt 文件中写入 url 字符串。这是因为，当文件流对象的生命周期结束时，会自行调用其析构函数，该函数内部在销毁对象之前，会先调用 close() 方法切断它与任何文件的关联，最后才销毁它。

> 强烈建议读者，使用 open() 方法打开的文件，一定要手动调用 close() 方法关闭，这样可以避免程序发生一些奇葩的错误！


值得一提的是，《[C++处理输入输出错误](http://c.biancheng.net/view/3755.html)》一节中介绍了 4 种流状态，它们也同样适用于文件流。当文件流对象未关联任何文件时，调用 close() 方法会失败，其会为文件流设置 failbit 状态标志，该标志可以被 fail() 成员方法捕获。例如：

```c++
#include <iostream>#include <fstream>using namespace std;int main(){    const char *url="http://c.biancheng.net/cplus/";    ofstream outFile;    outFile.close();    if (outFile.fail()) {        cout << "文件操作过程发生了错误！";    }    return 0;}
```

程序执行结果为：

文件操作过程发生了错误！

## 11.6 C++打开的文件一定要用close()方法关闭！

通过前面的学习我们知道，C++ 使用 open() 方法打开文件，使用 close() 方法关闭文件。例如（程序一）：

```c++
#include <iostream>     //std::cout#include <fstream>        //std::ofstreamusing namespace std;int main(){    const char * url = "http://c.biancheng.net/cplus/";    //以文本模式打开out.txt    ofstream destFile("out.txt", ios::out);    if (!destFile) {        cout << "文件打开失败" << endl;        return 0;    }    //向out.txt文件中写入 url 字符串    destFile << url;    //关闭打开的 out.txt 文件    destFile.close();    return 0;}
```

执行该程序，会生成一个 out.txt 文件，内部存有如下内容：

http://c.biancheng.net/cplus/


前面提到，在某些情况下（例如上面程序中），即便不显式调用 close() 方法，文件的读写操作也能成功执行。因为当文件流对象的生命周期结束时，会自行调用析构函数，此函数内部会先调用 close() 方法切断文件流对象与任何文件的关联，最后才销毁它。

那么，既然文件流对象自行销毁时会隐式调用 close() 方法，是不是就不用显式调用 close() 方法了呢？

当然不是。在实际进行文件操作的过程中，对于打开的文件，要及时调用 close() 方法将其关闭，否则很可能会导致读写文件失败。

举个例子（程序二）：

```c++
#include <iostream>     //std::cout#include <fstream>      //std::ofstreamusing namespace std;int main(){    const char * url = "http://c.biancheng.net/cplus/";    //以文本模式打开out.txt    ofstream destFile("out.txt", ios::out);    if (!destFile) {        cout << "文件打开失败" << endl;        return 0;    }    //向out.txt文件中写入 url 字符串    destFile << url;    //程序抛出一个异常    throw "Exception";    //关闭打开的 out.txt 文件    destFile.close();    return 0;}
```

通过对比不难发现，此程序和程序一唯一的区别在于，第 17 行添加了抛出异常的语句。由于程序中没有对抛出的异常进行处理，因此当程序执行到此行时会崩溃。

更重要的是，第 17 行会导致文件写入操作失败。执行此程序，同样会生成 out.txt 文件，但 "http:c.biancheng.net/cplus/" 字符串并没有成功被写入。

也就是说，对于已经打开的文件，如果不及时关闭，一旦程序出现异常，则很可能会导致之前读写文件的所有操作失效。在程序二的基础上，如果将第 17 行代码和第 19 行代码互换，再次执行程序会发现，虽然程序执行仍会崩溃，但 "http:c.biancheng.net/cplus/" 字符串可以被成功写入到 out.txt 文件中。

#### C++ flush()刷新缓冲区

在很多实际场景中，即便已经对文件执行了写操作，但后续还可能会执行其他的写操作。对于这种情况，我们可能并不想频繁地打开/关闭文件，可以使用 flush() 方法及时刷新输出流缓冲区，也能起到防止写入文件失败的作用。

程序二之所以写入文件失败，是因为 << 写入运算符会先将 url 字符串写入到输出流缓冲区中，待缓冲区满或者关闭文件时，数据才会由缓冲区写入到文件中。但直到程序崩溃，close() 方法也没有得到执行，且 destFile 对象也没有正常销毁，所以 url 字符串一直存储在缓冲区中，没有写入到文件中。

比如，修改程序二的代码：

```c++
#include <iostream>     //std::cout#include <fstream>      //std::ofstreamusing namespace std;int main(){    const char * url = "http://c.biancheng.net/cplus/";    //以文本模式打开out.txt    ofstream destFile("out.txt", ios::out);    if (!destFile) {        cout << "文件打开失败" << endl;        return 0;    }    //向out.txt文件中写入 url 字符串    destFile << url;    //刷新输出流缓冲区    destFile.flush();    //程序抛出一个异常    throw "Exception";    //关闭打开的 out.txt 文件    destFile.close();    return 0;}
```

可以看到，在程序二的基础上，在第 17 行调用了 flush() 方法。再次执行程序，虽然仍执行崩溃，但 "http://c.baincheng.net/cplus/" 字符串成功写入到了 out.txt 文件中。

总之，C++ 中使用 open() 打开的文件，在读写操作执行完毕后，应及时调用 close() 方法关闭文件，或者对文件执行写操作后及时调用 flush() 方法刷新输出流缓冲区。

## 11.7 C++文本文件读写操作详解

前面章节中，已经给大家介绍了文件流对象如何调用 open() 方法打开文件，并且在读写（又称 I/O ）文件操作结束后，应调用 close() 方法关闭先前打开的文件。那么，如何实现对文件内容的读写呢？接下来就对此问题做详细的讲解。

在讲解具体读写文件的方法之前，读者首先要搞清楚的是，对文件的读/写操作又可以细分为 2 类，分别是以文本形式读写文件和以二进制形式读写文件。

\1) 我们知道，文件中存储的数据并没有类型上的分别，统统都是字符。所谓以文本形式读/写文件，就是直白地将文件中存储的字符（或字符串）读取出来，以及将目标字符（或字符串）存储在文件中。

\2) 而以二进制形式读/写文件，操作的对象不再是打开文件就能看到的字符，而是文件底层存储的二进制数据。更详细地讲，当以该形式读取文件时，读取的是该文件底层存储的二进制数据；同样，当将某数据以二进制形式写入到文件中时，写入的也是其对应的二进制数据。

举个例子，假设我们以文本形式将浮点数 19.625 写入文件，则该文件会直接将 "19.625" 这个字符串存储起来。当我们双击打开此文件，也可以看到 19.625。值得一提的是，由非字符串数据（比如这里的浮点数 19.625）转换为对应字符串（转化为 "19.625"）的过程，C++ 标准库已经实现好了，不需要我们操心。

但如果以二进制形式将浮点数 19.625 写入文件，则该文件存储的不再是 "19.625" 这个字符串，而是 19.625 浮点数对应的二进制数据。以 float 类型的 19.625 来说，文件最终存储的数据如下所示：

0100 0001 1001 1101 0000 0000 0000 0000

> 至于如何得出 float 类型的 19.625 对应的二进制，感兴趣的读者可阅读《[小数在内存中是如何存储的](http://c.biancheng.net/view/vip_1764.html)》一节。

显然，如果直接将以上二进制数据转换为 float 类型，仍可以得到浮点数 19.625。但对于文件来说，它只会将存储的二进制数据根据既定的编码格式（如 utf-8、gbk 等）转换为一个个字符。这也就意味着，如果我们直接打开此文件，看到的并不会是 19.625，往往是一堆乱码。

C++ 标准库中，提供了 2 套读写文件的方法组合，分别是：

1. 使用 >> 和 << 读写文件：适用于以文本形式读写文件；
2. 使用 read() 和 write() 成员方法读写文件：适用于以二进制形式读写文件。


本节先讲解如何用 >> 和 << 实现以文本形式读写文件，至于如何实现以二进制形式读写文件，下一节会做详细介绍。

### C++ >>和<<读写文本文件

通过《[C++文件流类](http://c.biancheng.net/view/7591.html)》一节的学习我们知道，fstream 或者 ifstream 类负责实现对文件的读取，它们内部都对 >> 输出流运算符做了重载；同样，fstream 和 ofstream 类负责实现对文件的写入，它们的内部也都对 << 输出流运算符做了重载。

所以，当 fstream 或者 ifstream 类对象打开文件（通常以 ios::in 作为打开模式）之后，就可以直接借助 >> 输入流运算符，读取文件中存储的字符（或字符串）；当 fstream 或者 ofstream 类对象打开文件（通常以 ios::out 作为打开模式）后，可以直接借助 << 输出流运算符向文件中写入字符（或字符串）。

举个例子：

```c++
#include <iostream>#include <fstream>using namespace std;int main(){    int x,sum=0;    ifstream srcFile("in.txt", ios::in); //以文本模式打开in.txt备读    if (!srcFile) { //打开失败        cout << "error opening source file." << endl;        return 0;    }    ofstream destFile("out.txt", ios::out); //以文本模式打开out.txt备写    if (!destFile) {        srcFile.close(); //程序结束前不能忘记关闭以前打开过的文件        cout << "error opening destination file." << endl;        return 0;    }    //可以像用cin那样用ifstream对象    while (srcFile >> x) {        sum += x;        //可以像 cout 那样使用 ofstream 对象        destFile << x << " ";    }    cout << "sum：" << sum << endl;    destFile.close();    srcFile.close();    return 0;}
```

> 注意，此程序中分别采用 ios::in 和 ios::out 打开文件，即以文本模式而非二进制模式打开文件。感兴趣的读者可在其基础上添加 ios::binary，即以二进制模式打开文件，程序依旧会正常执行。这是因为，以文本模式打开文件和以二进制模式打开文件，并没有很大的区别（后续章节会做详细讲解）。

执行此程序之前，必须在和该程序源文件同目录中手动创建一个 in.txt 文件，假设其内部存储的字符串为：

10 20 30 40 50

建立之后，执行程序，其执行结果为：

sum：150

同时在 in.txt 文件同目录下，会生成一个 out.txt 文件，其内部存储的字符和 in.txt 文件完全一样，读者可自行打开文件查看。

通过分析程序的执行结果不难理解，对于 in.txt 文件中的 "10 20 30 40 50" 字符串，srcFile 对象会依次将 "10"、"20"、"30"、"40"、"50" 读取出来，将它们解析成 int 类型的整数 10、20、30、40、50 并赋值给 x，同时完成和 sum 的加和操作。

同样，对于每次从 in.txt 文件读取并解析出的整形 x，destFile 对象都会原封不动地将其再解析成对应的字符串（如整数 10 解析成字符串 "10"），然后和 " " 空格符一起写入 out.txt 文件。

## 11.8 C++ read()和write()读写二进制文件（超级详细）

通过《[C++文本文件读写操作](http://c.biancheng.net/view/7596.html)》一节的学习，读者了解了以文本形式读写文件和以二进制形式读写文件的区别，并掌握了用重载的 >> 和 << 运算符实现以文本形式读写文件。在此基础上，本节继续讲解如何以二进制形式读写文件。

不过介绍具体的实现方法前，先给读者介绍一下相比以文本形式读写文件，以二进制形式读写文件有哪些好处？

举个例子，现在要做一个学籍管理程序，其中一个重要的工作就是记录学生的学号、姓名、年龄等信息。这意味着，我们需要用一个类来表示学生，如下所示：

```c++
class CStudent{    char szName[20];  //假设学生姓名不超过19个字符，以 '\0' 结尾    char szId[l0];  //假设学号为9位，以 '\0' 结尾    int age;  //年龄};
```

前面章节中，我们学会了如何以文本形式读写文件，如果使用此方式存储学生的信息，则最终的文件中存储的学生信息可能是这个样子：

Micheal Jackson 110923412 17
Tom Hanks 110923413 18
......

要知道，这种存储学生信息的方式不但浪费空间，而且后期不利于查找指定学生的信息（查找效率低下），因为每个学生的信息所占用的字节数不同。

这种情况下，以二进制形式将学生信息存储到文件中，是非常不错的选择，因为以此形式存储学生信息，可以直接把 CStudent 对象写入文件中，这意味着每个学生的信息都只占用 sizeof(CStudent) 个字节。

值得一提的是，要实现以二进制形式读写文件，<< 和 >> 将不再适用，需要使用 C++ 标准库专门提供的 read() 和 write() 成员方法。其中，read() 方法用于以二进制形式从文件中读取数据；write() 方法用于以二进制形式将数据写入文件。

### C++ ostream::write()方法写文件

ofstream 和 fstream 的 write() 成员方法实际上继承自 ostream 类，其功能是将内存中 buffer 指向的 count 个字节的内容写入文件，基本格式如下：

```c++
ostream & write(char* buffer, int count);
```

其中，buffer 用于指定要写入文件的二进制数据的起始位置；count 用于指定写入字节的个数。

> 也就是说，该方法可以被 ostream 类的 cout 对象调用，常用于向屏幕上输出字符串。同时，它还可以被 ofstream 或者 fstream 对象调用，用于将指定个数的二进制数据写入文件。

同时，该方法会返回一个作用于该函数的引用形式的对象。举个例子，obj.write() 方法的返回值就是对 obj 对象的引用。

需要注意的一点是，write() 成员方法向文件中写入若干字节，可是调用 write() 函数时并没有指定这些字节写入文件中的具体位置。事实上，write() 方法会从文件写指针指向的位置将二进制数据写入。所谓文件写指针，是是 ofstream 或 fstream 对象内部维护的一个变量，文件刚打开时，文件写指针指向的是文件的开头（如果以 ios::app 方式打开，则指向文件末尾），用 write() 方法写入 n 个字节，写指针指向的位置就向后移动 n 个字节。

下面的程序演示了如何将学生信息以二进制形式写入文件：

```c++
#include <iostream>#include <fstream>using namespace std;class CStudent{public:    char szName[20];    int age;};int main(){    CStudent s;    ofstream outFile("students.dat", ios::out | ios::binary);    while (cin >> s.szName >> s.age)        outFile.write((char*)&s, sizeof(s));    outFile.close();    return 0;}
```

输入：

Tom 60↙
Jack 80↙
Jane 40↙
^Z↙

其中，`↙`表示输出换行符，^Z 表示输入`Ctrl+Z`组合键结束输入。

执行程序后，会自动生成一个 students.dat 文件，其内部存有 72 字节的数据，如果用“记事本”打开此文件，可能看到如下乱码：

Tom 烫烫烫烫烫烫烫烫<  Jack 烫烫烫烫烫烫烫蘌  Jane 烫烫烫烫烫烫烫?

值得一提的是，程序中第 13 行指定文件的打开模式为 ios::out | ios::binary，即以二进制写模式打开。在 Windows平台中，以二进制模式打开文件是非常有必要的，否则可能出错，原因会在《[文件的文本打开方式和二进制打开方式的区别](http://c.biancheng.net/view/311.html)》一节中介绍。

另外，第 15 行将 s 对象写入文件。s 的地址就是要写入文件的内存缓冲区的地址，但是 &s 不是 char * 类型，因此要进行强制类型转换；第 16 行，文件使用完毕一定要关闭，否则程序结束后文件的内容可能不完整。

### C++ istream::read()方法读文件

ifstream 和 fstream 的 read() 方法实际上继承自 istream 类，其功能正好和 write() 方法相反，即从文件中读取 count 个字节的数据。该方法的语法格式如下：

```c++
istream & read(char* buffer, int count);
```

其中，buffer 用于指定读取字节的起始位置，count 指定读取字节的个数。同样，该方法也会返回一个调用该方法的对象的引用。

和 write() 方法类似，read() 方法从文件读指针指向的位置开始读取若干字节。所谓文件读指针，可以理解为是 ifstream 或 fstream 对象内部维护的一个变量。文件刚打开时，文件读指针指向文件的开头（如果以 ios::app 方式打开，则指向文件末尾），用 read() 方法读取 n 个字节，读指针指向的位置就向后移动 n 个字节。因此，打开一个文件后连续调用 read() 方法，就能将整个文件的内容读取出来。

通过执行 write() 方法的示例程序，我们将 3 个学生的信息存储到了 students.dat 文件中，下面程序演示了如何使用 read() 方法将它们读取出来：

```c++
#include <iostream>#include <fstream>using namespace std;class CStudent{public:    char szName[20];    int age;};int main(){    CStudent s;           ifstream inFile("students.dat",ios::in|ios::binary); //二进制读方式打开    if(!inFile) {        cout << "error" <<endl;        return 0;    }    while(inFile.read((char *)&s, sizeof(s))) { //一直读到文件结束        cout << s.szName << " " << s.age << endl;       }    inFile.close();    return 0;}
```

程序的输出结果是：

Tom 60
Jack 80
Jane 40

注意，程序中第 18 行直接将 read() 方法作为 while 循环的判断条件，这意味着，read() 方法会一直读取到文件的末尾，将所有字节全部读取完毕，while 循环才会终止。

> 另外，在使用 read() 方法的同时，如果想知道一共成功读取了多少个字节（读到文件尾时，未必能读取 count 个字节），可以在 read() 方法执行后立即调用文件流对象的 gcount() 成员方法，其返回值就是最近一次 read() 方法成功读取的字节数。感兴趣的读者可自行尝试，这里不再做具体演示。

## 11.9 C++ get()和put()读写文件详解

在某些特殊的场景中，我们可能需要逐个读取文件中存储的字符，或者逐个将字符存储到文件中。这种情况下，就可以调用 get() 和 put() 成员方法实现。

### C++ ostream::put()成员方法

通过《[C++ cout.put()](http://c.biancheng.net/view/3750.html)》一节的学习，读者掌握了如何通过执行 cout.put() 方法向屏幕输出单个字符。我们知道，fstream 和 ofstream 类继承自 ostream 类，因此 fstream 和 ofstream 类对象都可以调用 put() 方法。

当 fstream 和 ofstream 文件流对象调用 put() 方法时，该方法的功能就变成了向指定文件中写入单个字符。put() 方法的语法格式如下：

```c++
ostream& put (char c);
```

其中，c 用于指定要写入文件的字符。该方法会返回一个调用该方法的对象的引用形式。例如，obj.put() 方法会返回 obj 这个对象的引用。

举个例子：

```c++
#include <iostream>#include <fstream>using namespace std;int main(){    char c;    //以二进制形式打开文件    ofstream outFile("out.txt", ios::out | ios::binary);    if (!outFile) {        cout << "error" << endl;        return 0;    }    while (cin >> c) {        //将字符 c 写入 out.txt 文件        outFile.put(c);    }    outFile.close();    return 0;}
```

执行程序，输入：

http://c.biancheng.net/cplus/↙
^Z↙

> 其中，`↙`表示输入换行符；`^Z`是 Ctrl+Z 的组合键，表示输入结束。

由此，程序中通过执行 while 循环，会将 "http://c.biancheng.net/cplus/" 字符串的字符逐个复制给变量 c，并逐个写入到 out.txt 文件。

> 注意，由于文件存放在硬盘中，硬盘的访问速度远远低于内存。如果每次写一个字节都要访问硬盘，那么文件的读写速度就会慢得不可忍受。因此，操作系统在接收到 put() 方法写文件的请求时，会先将指定字符存储在一块指定的内存空间中（称为文件流输出缓冲区），等刷新该缓冲区（缓冲区满、关闭文件、手动调用 flush() 方法等，都会导致缓冲区刷新）时，才会将缓冲区中存储的所有字符“一股脑儿”全写入文件。

### C++ istream::get()成员方法

和 put() 成员方法的功能相对的是 get() 方法，其定义在 istream 类中，借助 cin.get() 可以读取用户输入的字符。在此基础上，fstream 和 ifstream 类继承自 istream 类，因此 fstream 和 ifstream 类的对象也能调用 get() 方法。

当 fstream 和 ifstream 文件流对象调用 get() 方法时，其功能就变成了从指定文件中读取单个字符（还可以读取指定长度的字符串）。值得一提的是，get() 方法的语法格式有很多（[请猛击这里了解详情](http://www.cplusplus.com/reference/istream/istream/get/)），这里仅介绍最常用的 2 种：

```c++
int get();istream& get (char& c);
```

其中，第一种语法格式的返回值就是读取到的字符，只不过返回的是它的 ASCII 码，如果碰到输入的末尾，则返回值为 EOF。第二种语法格式需要传递一个字符变量，get() 方法会自行将读取到的字符赋值给这个变量。

本节前面在讲解 put() 方法时，生成了一个 out.txt 文件，下面的样例演示了如何通过 get() 方法逐个读取 out.txt 文件中的字符：

```c++
#include <iostream>#include <fstream>using namespace std;int main(){    char c;    //以二进制形式打开文件    ifstream inFile("out.txt", ios::out | ios::binary);    if (!inFile) {        cout << "error" << endl;        return 0;    }    while ( (c=inFile.get())&&c!=EOF )   //或者 while(inFile.get(c))，对应第二种语法格式    {        cout << c ;    }    inFile.close();    return 0;}
```

程序执行结果为：

http://c.biancheng.net/cplus/

注意，和 put() 方法一样，操作系统在接收到 get() 方法的请求后，哪怕只读取一个字符，也会一次性从文件中将很多数据（通常至少是 512 个字节，因为硬盘的一个扇区是 512 B）读到一块内存空间中（可称为文件流输入缓冲区），这样当读取下一个字符时，就不需要再访问硬盘中的文件，直接从该缓冲区中读取即可。

## 11.10 C++ getline()：从文件中读取一行字符串

《[cin.getline()](http://c.biancheng.net/view/279.html)》一节中，详细介绍了如何使用 getline() 方法从 cin 输入流缓冲区中读取一行字符串。在此基础上，getline() 方法还适用于读取指定文件中的一行数据，本节就给大家做详细的讲解。

我们知道，getline() 方法定义在 istream 类中，而 fstream 和 ifstream 类继承自 istream 类，因此 fstream 和 ifstream 的类对象可以调用 getline() 成员方法。

当文件流对象调用 getline() 方法时，该方法的功能就变成了从指定文件中读取一行字符串。该方法有以下 2 种语法格式：

```c++
istream & getline(char* buf, int bufSize);istream & getline(char* buf, int bufSize, char delim);
```

其中，第一种语法格式用于从文件输入流缓冲区中读取 bufSize-1 个字符到 buf，或遇到 \n 为止（哪个条件先满足就按哪个执行），该方法会自动在 buf 中读入数据的结尾添加 '\0'。

第二种语法格式和第一种的区别在于，第一个版本是读到 \n 为止，第二个版本是读到 delim 字符为止。\n 或 delim 都不会被读入 buf，但会被从文件输入流缓冲区中取走。

以上 2 种格式中，getline() 方法都会返回一个当前所作用对象的引用。比如，obj.getline() 会返回 obj 的引用。

> 注意，如果文件输入流中 \n 或 delim 之前的字符个数达到或超过 bufSize，就会导致读取失败。

举个例子：

```c++
#include <iostream>#include <fstream>using namespace std;int main(){    char c[40];    //以二进制模式打开 in.txt 文件    ifstream inFile("in.txt", ios::in | ios::binary);    //判断文件是否正常打开    if (!inFile) {        cout << "error" << endl;        return 0;    }    //从 in.txt 文件中读取一行字符串，最多不超过 39 个    inFile.getline(c, 40);    cout << c ;    inFile.close();    return 0;}
```

假设 in.txt 文件中存有如下字符串：

http://c.biancheng.net/cplus/

则程序执行结果为：

http://c.biancheng.net/cplus/


当然，我们也可以使用 getline() 方法的第二种语法格式。例如，更改上面程序中第 15 行代码为：

```c++
inFile.getline(c,40,'c');
```

这意味着，一旦遇到字符 'c'，getline() 方法就会停止读取。 再次运行程序，其输出结果为：

http://


另外，如果想读取文件中的多行数据，可以这样做：

```c++
#include <iostream>#include <fstream>using namespace std;int main(){    char c[40];    ifstream inFile("in.txt", ios::in | ios::binary);    if (!inFile) {        cout << "error" << endl;        return 0;    }    //连续以行为单位，读取 in.txt 文件中的数据    while (inFile.getline(c, 40)) {        cout << c << endl;    }    inFile.close();    return 0;}
```

假设 in.txt 文件中存有如下数据：

http://c.biancheng.net/cplus/
http://c.biancheng.net/python/
http://c.biancheng.net/java/

则程序执行结果为：

http://c.biancheng.net/cplus/
http://c.biancheng.net/python/
http://c.biancheng.net/java/

## 11.11 C++移动和获取文件读写指针（seekp、seekg、tellg、tellp）

在读写文件时，有时希望直接跳到文件中的某处开始读写，这就需要先将文件的读写[指针](http://c.biancheng.net/c/80/)指向该处，然后再进行读写。

- ifstream 类和 fstream 类有 seekg 成员函数，可以设置文件读指针的位置；
- ofstream 类和 fstream 类有 seekp 成员函数，可以设置文件写指针的位置。


所谓“位置”，就是指距离文件开头有多少个字节。文件开头的位置是 0。

这两个函数的原型如下：

```c++
ostream & seekp (int offset, int mode);istream & seekg (int offset, int mode);
```

mode 代表文件读写指针的设置模式，有以下三种选项：

- ios::beg：让文件读指针（或写指针）指向从文件开始向后的 offset 字节处。offset 等于 0 即代表文件开头。在此情况下，offset 只能是非负数。
- ios::cur：在此情况下，offset 为负数则表示将读指针（或写指针）从当前位置朝文件开头方向移动 offset 字节，为正数则表示将读指针（或写指针）从当前位置朝文件尾部移动 offset字节，为 0 则不移动。
- ios::end：让文件读指针（或写指针）指向从文件结尾往前的 |offset|（offset 的绝对值）字节处。在此情况下，offset 只能是 0 或者负数。


此外，我们还可以得到当前读写指针的具体位置：

- ifstream 类和 fstream 类还有 tellg 成员函数，能够返回文件读指针的位置；
- ofstream 类和 fstream 类还有 tellp 成员函数，能够返回文件写指针的位置。


这两个成员函数的原型如下：

```c++
int tellg();int tellp();
```

要获取文件长度，可以用 seekg 函数将文件读指针定位到文件尾部，再用 tellg 函数获取文件读指针的位置，此位置即为文件长度。

例题：假设学生记录文件 students.dat 是按照姓名排好序的，编写程序，在 students.dat 文件中用折半查找的方法找到姓名为 Jack 的学生记录，并将其年龄改为 20（假设文件很大，无法全部读入内存）。程序如下：

```c++
#include <iostream>#include <fstream>#include <cstring>using namespace std;class CStudent{    public:        char szName[20];        int age;};int main(){    CStudent s;           fstream ioFile("students.dat", ios::in|ios::out);//用既读又写的方式打开    if(!ioFile) {        cout << "error" ;        return 0;    }    ioFile.seekg(0,ios::end); //定位读指针到文件尾部，                              //以便用以后tellg 获取文件长度    int L = 0,R; // L是折半查找范围内第一个记录的序号                  // R是折半查找范围内最后一个记录的序号    R = ioFile.tellg() / sizeof(CStudent) - 1;    //首次查找范围的最后一个记录的序号就是: 记录总数- 1    do {        int mid = (L + R)/2; //要用查找范围正中的记录和待查找的名字比对        ioFile.seekg(mid *sizeof(CStudent),ios::beg); //定位到正中的记录        ioFile.read((char *)&s, sizeof(s));        int tmp = strcmp( s.szName,"Jack");        if(tmp == 0) { //找到了            s.age = 20;            ioFile.seekp(mid*sizeof(CStudent),ios::beg);            ioFile.write((char*)&s, sizeof(s));            break;        }        else if (tmp > 0) //继续到前一半查找            R = mid - 1 ;        else  //继续到后一半查找            L = mid + 1;    }while(L <= R);    ioFile.close();    return 0;}
```

# 12 C++多文件编程

## 12.2 C++如何防止头文件被重复引入（3种方法）？

《[防止C语言头文件被重复包含](http://c.biancheng.net/view/vip_2120.html)》一节中，详细介绍了 C 语言中如何使用宏定义（#ifndef / #define / #endif）来有效避免头文件被重复 #include，此方式在 C++ 多文件编程中也很常用。

举个例子，如下是一个 C++ 项目，其内部含有 school.h 和 student.h 这 2 个头文件以及 main.cpp 源文件，其各自包含的代码为：

```asciiarmor
//student.hclass Student {    //......};//school.h#include "student.h"class School {    //......private:    Student stu[50];};//main.cpp#include "student.h"#include "school.h"int main() {    //......    return 0;}
```

运行此项目读者会发现，编译器报“Student 类型重定义”错误。这是因为在 school.h 文件中已经 #include 了一次 "student.h"，而在 main.cpp 主程序又同时 #include 了 "school.h" 和 "student.h"，即 Student 类的定义被引入了 2 次，C++不允许同一个类被重复定义。

有读者可能想到，既然 School.h 文件中已经引入了 Student 类，那去掉 main.cpp 主程序引入的 student.h 文件不就可以了吗？这样确实可以避免重复引入 Student 类，但此方式并不适用于所有“重复引入”的场景。

C++ 多文件编程中，处理“多次 #include 导致重复引入”问题的方式有以下 3 种。

### 1) 使用宏定义避免重复引入

在实际多文件开发中，我们往往使用如下的宏定义来避免发生重复引入：

```c++
#ifndef _NAME_H#define _NAME_H//头文件内容#endif
```

其中，_NAME_H 是宏的名称。需要注意的是，这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同。

当程序中第一次 #include 该文件时，由于 _NAME_H 尚未定义，所以会定义 _NAME_H 并执行“头文件内容”部分的代码；当发生多次 #include 时，因为前面已经定义了 _NAME_H，所以不会再重复执行“头文件内容”部分的代码。

也就是说，我们可以将前面项目中的 student.h 文件做如下修改：

```c++
#ifndef _STUDENT_H#define _STUDENT_Hclass Student {    //......};#endif
```

虽然该项目 main.cpp 文件中仍 #include 了 2 次 "student.h"，但鉴于 _STUDENT_H 宏只能定义一次，所以 Student 类也仅会定义一次。再次执行该项目会发现，其可以正常执行。

### 2) 使用#pragma once避免重复引入

除了前面第一种最常用的方式之外，还可以使用 #pragma one 指令，将其附加到指定文件的最开头位置，则该文件就只会被 #include 一次。

我们知道，#ifndef 是通过定义独一无二的宏来避免重复引入的，这意味着每次引入头文件都要进行识别，所以效率不高。但考虑到 C 和 C++ 都支持宏定义，所以项目中使用 #ifndef 规避可能出现的“头文件重复引入”问题，不会影响项目的可移植性。

和 ifndef 相比，#pragma once 不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高。但值得一提的是，并不是每个版本的编译器都能识别 #pragma once 指令，一些较老版本的编译器就不支持该指令（执行时会发出警告，但编译会继续进行），即 #pragma once 指令的兼容性不是很好。

> 目前，几乎所有常见的编译器都支持 #pragma once 指令，甚至于 Visual Studio 2017 新建头文件时就会自带该指令。可以这么说，在 C/C++ 中，#pragma once 是一个非标准但却逐渐被很多编译器支持的指令。

除此之外，#pragma once 只能作用于某个具体的文件，而无法向 #ifndef 那样仅作用于指定的一段代码。

这里仍以前面的 "student.h" 文件为例，将其内容修改为：

```c++
#pragma onceclass Student {    //......};
```

再次运行项目，同样可以正常执行。

### 3) 使用_Pragma操作符

C99 标准中新增加了一个和 #pragma 指令类似的 _Pragma 操作符，其可以看做是 #pragma 的增强版，不仅可以实现 #pragma 所有的功能，更重要的是，_Pragma 还能和宏搭配使用。

> 有关 _Pragma 操作符更多的功能和用法，本节不做详细讲解，这里仅介绍如何用 _Pragma 操作符避免头文件重复引入。

当处理头文件重复引入问题时，可以将如下语句添加到相应文件的开头：

```c++
_Pragma("once")
```

比如，将该语句添加到前面项目中 student.h 文件中的开头位置，再次执行项目，其可以正常执行。

> 事实上，无论是 C 语言还是 C++，为防止用户重复引入系统库文件，几乎所有库文件中都采用了以上 3 种结构中的一种，这也是为什么重复引入系统库文件编译器也不会报错的原因。

### 总结

本节介绍了 3 种避免头文件被重复引入的方法，其中 #pragma once 和 _Pragma("once") 可算作一类，其特点是编译效率高，但可移植性差（编译器不支持，会发出警告，但不会中断程序的执行）；而 #ifndef 的特点是可移植性高，编译效率差。读者可根据实际情况，挑选最符合实际需要的解决方案。

> 除非对项目的编译效率有严格的要求，强烈推荐读者选用第一种解决方案，即采用 #ifndef / #define / #endif 组合解决头文件被重复引入。

另外在某些场景中，考虑到编译效率和可移植性，#pragma once 和 #ifndef 经常被结合使用来避免头文件被重复引入。比如说：

```c++
#pragma once#ifndef _STUDENT_H#define _STUDENT_Hclass Student {    //......};#endif
```

当编译器可以识别 #pragma once 时，则整个文件仅被编译一次；反之，即便编译器不识别 #pragma once 指令，此时仍有 #ifndef 在发挥作用。

## 12.3 C++命名空间如何应用在多文件编程中？



《[C++命名空间](http://c.biancheng.net/view/2192.html)》一节讲到，C++ 引入命名空间是为了避免合作开发项目时产生命名冲突，例如：

```c++
#include <iostream>namespace Li {  //小李的变量定义    class Student {    public:        void display(){            std::cout << "Li::display" << std::endl;        }    };}namespace Han {  //小韩的变量定义    class Student {    public:        void display() {            std::cout << "Han::display" << std::endl;        }    };}int main() {    Li::Student stu1;    stu1.display();    Han::Student stu2;    stu2.display();    return 0;}
```

程序执行结果为：

Li::display
Han::display

如上所示，小李与小韩各自定义了以自己姓氏为名的命名空间，此时再将他们各自定义的 Student 类放在一起编译就不会有任何问题。

那么当进行多文件编程时，命名空间又该如何使用呢？一个项目的多个文件中可以使用同一个命名空间吗？接下来就对这些疑问做一一解答。

《[C++多文件编程是什么](http://c.biancheng.net/view/7630.html)》一节讲到，当进行多文件编程时，通常是将声明部分（例如变量、函数和类等）划分到 .h 文件中，将实现部分划分到 .cpp 文件中。在此基础上，如果要给变量、函数或者类指定命名空间，则该命令空间应至少包含它们的声明部分。所以当进行多文件编程时，命名空间常位于 .h 头文件中。

举个例子，如下是对之前程序做的合理划分：

```c++
//student_li.h#ifndef _STUDENT_LI_H#define _STUDENT_LI_Hnamespace Li {  //小李的变量定义    class Student {    public:        void display();    };}#endif//student_li.cpp#include "student_li.h"#include <iostream>void Li::Student::display() {    std::cout << "Li::display" << std::endl;}//student_han.h#ifndef _STUDENT_HAN_H#define _STUDENT_HAN_Hnamespace Han {  //小韩的变量定义    class Student {    public:        void display();    };}#endif//student_han.cpp#include "student_han.h"#include <iostream>void Han::Student::display() {    std::cout << "han::display" << std::endl;}//main.cpp#include <iostream>#include "student_han.h"#include "student_li.h"int main() {    Li::Student stu1;    stu1.display();    Han::Student stu2;    stu2.display();    return 0;}
```

项目执行结果为：

Li::display
han::display

> 注意，当类的声明位于指定的命名空间中时，如果要在类的外部实现其成员方法，需同时注明所在命名空间名和类名（例如本项目中的 Li::Student::display() ）。

上面的程序示例中，不同的头文件中使用的是不同的命名空间，除此之外，不同头文件中也可以使用名称相同的命名空间，但前提是位于该命名空间中的成员必须保证互不相同。

举个例子：

```c++
//demo1.h#ifndef _DEMO1_H#define _DEMO1_H#include<iostream>namespace demo {    void display() {        std::cout << "demo1::display" << std::endl;    }    int num=20;}#endif//demo2.h#ifndef _DEMO2_H#define _DEMO2_H#include <iostream>namespace demo {    void display(int a) {        std::cout << "demo2::display" << std::endl;    }    //int num; 因为 demo1.h 中已经声明有同名的变量，取消注释会造成重定义错误}#endif//main.cpp#include <iostream>#include "demo1.h"#include "demo2.h"int main() {    demo::display();    demo::display(2);    std::cout << demo::num << std::endl;    return 0;}
```

项目执行结果为：

demo1::display
demo2::display
20

> 注意，本例中 display() 函数的实现也位于 .h 文件中，仅仅是为了演示方便，读者可自行将该函数的声明和定义进行合理划分。

可以看到，demo1.h 和 demo2.h 文件中都定义有 demo 命名空间，当这 2 个头文件被引入到 main.cpp 文件中时，意味着 demo 空间中同时包含 display()、display(int n) 以及 num 这 3 个成员。也就是说，分散在不同文件中的同名命名空间会合并为一个。

> 再次强调，虽然同一项目的不同文件中可以定义相同的命名空间，但必须保证空间中的成员互不相同，否则编译器会报“重定义”错误。注意，这里的 display() 和 display(int n) 并不会造成重定义，它们互为重载函数。

## 12.4 C++ const常量如何在多文件编程中使用？

《[C++多文件编程是什么](http://c.biancheng.net/view/7630.html)》一节提到，多文件编程中代码的划分原则是：将变量、函数或者类的声明部分存放在 .h 文件，对应的实现部分放在 .cpp 文件中。值得一提得是，此规律适用于大部分场景，但本节要讲的 const 常量是一个例外。

我们知道，用 const 修饰的变量必须在定义的同时进行初始化操作（除非用 extern 修饰，本节后续会讲解）。与此同时，C++ 中 const 关键字的功能有 2 个，除了表明其修饰的变量为常量外，还将所修饰变量的可见范围限制为当前文件。这意味着，除非 const 常量的定义和 main 主函数位于同一个 .cpp 文件，否则该 const 常量只能在其所在的 .cpp 文件中使用。

那么，如何定义 const 常量，才能在其他文件中使用呢？接下来给读者介绍 3 种在 C++ 多文件编程中定义 const 常量的方法。

### 1) 将const常量定义在.h头文件中

首先介绍一种最常用也最简单的方法，就是将 const 常量定义在 .h 文件中。

> 显然此方式违背了“声明位于 .h 文件，定义（实现）位于 .cpp 文件”的规律。在 C++ 多文件编程中，还有 2 种特殊情况是违背此规律的，分别是类的定义和内联函数的定义，通常情况下它们也都定义在 .h 文件中。

举个例子（实例一）：

```c++
//demo.h#ifndef _DEMO_H#define _DEMO_Hconst int num = 10;#endif//main.cpp#include <iostream>#include"demo.h"int main() {    std::cout << num << std::endl;    return 0;}
```

项目执行结果为：

10

> 注意，将 const 常量定义在 .h 文件中，为了避免头文件被重复引入，推荐使用 #ifndef/#define/#endif 结构。除此之外，还有 2 中方式可以避免头文件被重复引入，读者可阅读《[C++防止头文件被重复引入的3种方法](http://c.biancheng.net/view/7636.html)》一文做详细了解。

可以看到，使用此方式定义的 const 常量，只需引入其头文件（比如这里的 demo.h），就可以使用它。

### 2) 借助extern先声明再定义const常量

当然，const 常量的定义也可以遵循“声明在 .h 文件，定义在 .cpp 文件”，借助 extern 关键字即可。例如（实例二）：

```c++
//demo.h#ifndef _DEMO_H#define _DEMO_Hextern const int num;  //声明 const 常量#endif//demo.cpp#include "demo.h"   //一定要引入该头文件const int num =10;  //定义 .h 文件中声明的 num 常量//main.cpp#include <iostream>#include "demo.h"int main() {    std::cout << num << std::endl;    return 0;}
```

项目执行结果为：

10

前面讲过，C++ const 关键字会限定变量的可见范围为当前文件，即无法在其它文件中使用该常量。而 extern 关键字会 const 限定可见范围的功能，它可以使 const 常量的可见范围恢复至整个项目。

### 3) 借助extern直接定义const常量

值得一提的是，第 2 种使用 extern 定义 const 常量的方式，还可以做进一步优化。

以实例二为例，demo.cpp 和 main.cpp 中都引入了 demo.h，而 demo.h 文件中只包含对 const num 常量的声明。要知道 C++ 编译器在运行项目时，会在预处理阶段直接将 #include 引入的头文件替换成该头文件中的内容（就可以理解为傻瓜式的复制粘贴）。

因此，我们可以将实例二中的项目做如下修改：

```c++
//demo.cppextern const int num =10;//main.cpp#include <iostream>extern const int num;int main() {    std::cout << num << std::endl;    return 0;}
```

项目执行结果为：

10

显然相比实例二，此项目中省略了 demo.h 头文件的创建，一定程序上提高了项目的编译效率。

> 本节介绍了 3 种在多文件编程中使用 const 常量的方法，相比后 2 种借助 extern 修饰 const 常量的方式，第一种方式更简单、更常用，推荐读者使用。

## 12.5 C++多文件项目如何用g++命令执行？

在不同的系统平台上，执行 C++ 程序的常用方式也有所不同。比如说在 Windows 平台上，我们经常使用 Visual Studio、dev C++、codeblocks 这些 IDE 执行 C++ 程序；而在 Linux 平台上，虽然也有很多可用的 C++ IDE，但执行 C++ 程序更常采用的方式是使用 g++ 命令。

> 除此之外，Linux 平台上还经常编写 makefile 来运行规模较大的 C++ 项目。关于 makefile，读者可阅读《[Makefile教程：Makefile文件编写1天入门](http://c.biancheng.net/makefile/)》专题做详细了解。

本节将在 CentOS 系统下（Linux 发行版之一），为读者演示如何使用 g++ 命令执行 C++ 程序。

### 安装g++编译器

值得一提的是，CentOS 系统并没有默认安装 g++ 编译器，需要我们自行安装。读者也可以使用如下命令验证当前环境中是否已经安装有 g++。

打开 Terminal 终端并执行如下命令：

[root@bogon ~]# which g++
/usr/bin/g++

可以看到，我所使用的系统环境中，已经安装好了 g++，其位于 /user/bin/g++ 目录中。如果读者所使用的系统环境中也已安装好了 g++ 编译器，可以跳过此安装环节。

对于尚未安装 g++ 编译器的读者，可直接在终端中执行如下命令：

yum install gcc-c++

注意，该命令执行时可能会提示“你需要以 root 权限执行此命令”，这种情况下可以输入`su`命令，然后输入 root 用户的登陆密码，再次执行安装指令即可成功安装。

### g++命令执行C++项目

《[那些被编译器隐藏了的过程](http://c.biancheng.net/view/vip_2111.html)》一节中讲到，C 或者 C++ 程序的执行过程分为 4 步，依次是预处理、编译、汇编和链接。

我们知道，C++ 多文件编程中有头文件（.h 为后缀）和源文件（.cpp为后缀）之分。需要注意的是，在执行 C++ 项目时，头文件是不需要经历以上这 4 个阶段的，只有项目中的所有源文件才必须经历这 4 个阶段。

假设有这样一个 C++ 项目：

```c++
//student.hclass Student {public:    const char *name;    int age;    float score;    void say();};//student.cpp#include <iostream>   //std::cout、std::endl#include "student.h"  //Studentvoid Student::say() {    std::cout << name << "的年龄是" << age << "，成绩是" << score << std::endl;}//main.cpp#include "student.h"  //Studentint main() {    Student *pStu = new Student;    pStu->name = "小明";    pStu->age = 15;    pStu->score = 92.5f;    pStu->say();    delete pStu;  //删除对象    return 0;}
```

该项目正确的执行结果为：

小明的年龄是15，成绩是92.5


可以看到，当前项目中有 1 个 student.h 头文件，student.cpp 和 main.cpp 2 个源文件。接下来就用 g++ 命令执行此项目，其过程依次是：

\1) 经历预处理阶段，执行如下命令：

[root@bogon ~]# g++ -E main.cpp -o main.i
[root@bogon ~]# g++ -E student.cpp -o student.i

其中，-E 选项用于限定 g++ 编译器只进行预处理而不进行后续的 3 个阶段；-o 选项用于指定生成文件的名称。Linux 系统中，通常用 ".i" 作为 C++ 程序预处理后所得文件的后缀名。

> 感兴趣的读者可自行运行`cat main.i`指令查看 main.i 文件中的内容（student.i文件也可以用此方式查看）。


\2) 经历编译阶段，即对预处理阶段得到的 -i 文件做进一步的语法分析，生成相应的汇编代码文件。继续执行如下命令：

[root@bogon ~]# g++ -S main.i -o main.s
[root@bogon ~]# g++ -S student.i -o student.s

其中，-S 选项用于限定 g++ 编译器对指定文件进行编译，得到的汇编代码文件通常以“.s”作为后缀名。感兴趣的读者可以使用 cat 命令查看生成文件的内容。

\3) 经历汇编阶段，即将汇编代码文件转换成可以执行的机器指令。继续执行如下命令：

[root@bogon ~]# g++ -c main.s -o main.o
[root@bogon ~]# g++ -c student.s -o student.o

-c 指令用于限定 g++ 编译器只进行汇编操作，最终生成的目标文件（本质就是二进制文件，但还无法执行）通常以“.o”作为后缀名。

\4) 经历链接阶段，即将所有的目标文件组织成一个可以执行的二进制文件。执行如下命令：

[root@bogon ~]# g++ main.o student.o -o student.exe

注意，如果不用 -o 指定可执行文件的名称，默认情况下会生成 a.out 可执行文件。Linux 系统并不以文件的扩展名开分区文件类型，所以 a.out 和 student.exe 都是可执行文件，只是文件名称有区别罢了。

> 以上 4 个阶段中，文件的生成不分先后，只要保证所有源文件都得到处理即可。

经历以上 4 步，最终会生成 student.exe 可执行文件，其执行结果为：

[root@bogon ~]# ./student.exe
小明的年龄是15，成绩是92.5

> 注意“./”表示当前目录，不能省略。


读者可能觉得整个执行过程非常繁琐，直接执行如下命令即可生成最终的可执行文件：

[root@bogon ~]# g++ main.cpp student.cpp -o student.exe
[root@bogon ~]# ./student.exe
小明的年龄是15，成绩是92.5

> 强烈建议初学者学会使用前一种“繁琐”的执行方式，因为它有利于你更深入地了解 C++ 程序的执行过程。

## 12.6 读完本文，你就能彻底明白C++多文件编程！

在 C++ 多文件编程中，一个完整的 C++ 项目可以包含 2 类文件，即 .h 文件和 .cpp 文件。通常情况下，.h 文件称为 C++ 头文件，.cpp 文件称为 C++ 源文件。

通过 《[用g++命令执行C++多文件项目](http://c.biancheng.net/view/7669.html)》一节的学习我们知道，同属一个 C++ 项目中的所有代码文件是分别进行编译的，只需要在编译成目标文件后再与其它目标文件做一次链接即可。例如，在 a.cpp 源文件中定义有一个全局函数 a()，而在文件 b.cpp 中需要调用这个函数。即便如此，处于编译阶段的 a.cpp 和 b.cpp 并不需要知道对方的存在，它们各自是独立编译的是，只要最后将编译得到的目标文件进行链接，整个程序就可以运行。

那么，整个过程是如何实现的呢？从写程序的角度来理解，当文件 b.cpp 中需要调用 a() 函数时，只需要先声明一下该函数即可。这是因为，编译器在编译 b.cpp 时会生成一个符号表，类似 a() 这样看不到定义的符号就会被存放在这个表中。在链接阶段，编译器就会在别的目标文件中去寻找这个符号的定义，一旦找到了，程序也就可以 顺利地生成了（反之则出现链接错误）。

注意，这里提到了两个概念，即“声明”和“定义”。所谓定义，指的是就是将某个符号完整的描述清楚，它是变量还是函数，变量类型以及变量值是多少，函数的参数有哪些以及返回值是什么等等；而“声明”的作用仅是告诉编译器该符号的存在，至于该符号的具体的含义，只有等链接的时候才能知道。

> 也就是说，定义的时候需要遵循 C++ 语法规则完整地描绘一个符号，而声明的时候只需要给出该符号的原型即可。值得一提的是在 C++ 项目中，一个符号允许被声明多次，但只能被定义一次。理由很简单，如果一个符号出现多种定义，编译器该采用哪一个呢？

基于声明和定义的不同，才有了 C++ 多文件编程的出现。试想如果有一个很常用的函数 f()，其会被程序中的很多 .cpp 文件调用，那么我们只需要在一个文件中定义此函数，然后在需要调用的这些文件中声明这个函数就可以了。

那么问题来了，一个函数还好对付，声明起来也就一句话，如果有好几百个函数（比如是一大堆的数学函数），该怎么办呢？一种简单的方法就是将它们的声明全部放在一个文件中，当需要时直接从文件中拷贝。这种方式固然可行，但还是太麻烦，而且还显得很笨拙，于是头文件便可以发挥它的作用了。

所谓的头文件，其实它的内容跟 .cpp 文件中的内容是一样的，都是 C++ 的源代码，唯一的区别在于头文件不用被编译。我们把所有的函数声明全部放进一个头文件中，当某一个 .cpp 源文件需要时，可以通过 #include 宏命令直接将头文件中的所有内容引入到 .cpp 文件中。这样，当 .cpp 文件被编译之前（也就是预处理阶段），使用 #include 引入的 .h 文件就会替换成该文件中的所有声明。

以《[用g++命令执行C++多文件项目](http://c.biancheng.net/view/7669.html)》一节中的 C++ 项目为例，拥有 student.h、student.cpp 和 main.cpp 这 3 个文件，其中 student.cpp 和 main.cpp 文件中用 #include 引入了 student.h 文件。在此基础上，文章中用 g++ 命令分别对 student.cpp 和 main.cpp 进行了预处理操作，并分别生成了 student.i 和 main.i 文件。

如下展示了 main.i 文件中的内容：

```c++
class Student {public:    const char *name;    int age;    float score;    void say();};int main() {    Student *pStu = new Student;    pStu->name = "小明";    pStu->age = 15;    pStu->score = 92.5f;    pStu->say();    delete pStu;    return 0;}
```

显然和之前的 main.cpp 文件相比，抹去了用 #include 引入 student.h 文件，而是将 student.h 文件中所有的内容都拷贝了过来。

> \#include 是一个来自 C 语言的宏命令，作用于程序执行的预处理阶段，其功能是将它后面所写文件中的内容，完完整整、一字不差地拷贝到当前文件中。

### C++头文件内应该写什么

通过上面的讲解读者应该知道，.h 头文件的作用就是被其它的 .cpp 包含进去，其本身并不参与编译，但实际上它们的内容会在多个 .cpp 文件中得到编译。

通过“符号的定义只能 有一次”的规则，我们可以很容易地得出，头文件中应该只放变量和函数的声明，而不能放它们的定义。因为一个头文件的内容实际上是会被引入到多个不同的 .cpp 文件中的，并且它们都会被编译。换句话说，如果在头文件中放了定义，就等同于在多个 .cpp 文件中出现对同一个符号（变量或函数）的定义，纵然这些定义的内容相同，编译器也不认可这种做法（报“重定义”错误）。

所以读者一定要谨记，.h 头文件中只能存放变量或者函数的声明，而不要放定义。例如：

```c++
extern int a;void f();
```

这些都是声明。反之：

```c++
int a;void f() {}
```

这些都是定义，如果存放在 .h 文件中，一旦该文件被 2 个以上的 .cpp 文件引入，编译器就会立马报错。

凡事都有例外，以上 3 种情况也属于定义的范畴，但它们应该放在 .h 文件中：

#### 1) 头文件中可以定义 const 对象

要知道，全局的 const 对象默认是没有 extern 声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个 .cpp 文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。

与此同时，由于这些 .cpp 文件中的 const 对象都是从一个头文件中包含进去的，也就保证了这些 .cpp 文件中的 const 对象的值是相同的，可谓一举两得。

> 同理，static 对象的定义也可以放进头文件。

#### 2) 头文件中可以定义内联函数

内联函数（用 inline 修饰的函数）是需要编译器在编译阶段根据其定义将它内联展开的（类似宏展开），而并非像普通函数那样先声明再链接。这就意味着，编译器必须在编译时就找到内联函数的完整定义。

显然，把内联函数的定义放进一个头文件中是非常明智的做法。

> 有关 C++ 内联函数，读者可回顾《[C++ inline内联函数详解](http://c.biancheng.net/view/2201.html)》一节。

#### 3) 头文件中可以定义类

因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟内联函数是基本一样的，即把类的定义放进头文件，在使用到这个类的.cpp文件中去包含这个头文件。

值得一提的是，类的内部通常包含成员变量和成员函数，成员变量是要等到具体的对象被创建时才会被定义（分配空间），但成员函数却是需要在一开始就被定义的，这也就是类的实现。通常的做法是将类的定义放在头文件中，而把成员函数的实现代码放在一个 .cpp 文件中。

还有另一种办法，就是直接成员函数的实现代码写到类定义的内部。在 C++ 的类中，如果成员函数直接定义在类体的内部，则编译器会将其视为内联函数。所以把函数成员的定义写进类体内，一起放进头文件中，也是合法的。

注意，如果把成员函数的定义写在定义类的头文件中，而没有写进类内部，这是不合法的。这种情况下，此成员函数不是内联函数，一旦头文件被两个或两个以上的 .cpp 文件包含，就可能会出现重定义的错误。

## 有效避免头文件被重复引入

在 C++ 多文件编程中，如果 .h 头文件中只包含声明语句的话，即便被同一个 .cpp 文件引入多次也没有问题，因为声明语句是可以重复的，且重复次数不受限制。然而，刚刚讨论到的 3 种特殊情况也是头文件很常用的一个用处。如果一个头文件中出现了上面 3 种情况中的任何一种，且被同一个 .cpp 文件引入多次，就会发生重定义错误。

在 C++ 多文件编程中，为了有效避免“因多次引入头文件发生重定义”的问题，C++ 提供了 3 种处理机制，其中最常用的一种方式就是借助条件编译 #ifndef/#define/#endif，初学者一定要学会至少一种方式。

> 有关 C++ 中防止头文件被重复引入的 3 种方式，读者可回顾《[C++防止头文件被重复引入的3种方法](http://c.biancheng.net/view/7636.html)》一节。











# 多线程

在[Linux](https://so.csdn.net/so/search?from=pc_blog_highlight&q=Linux) C++开发环境中，通常有两种方式来开发[多线程](https://so.csdn.net/so/search?from=pc_blog_highlight&q=多线程)程序，一种是利用POSIX多线程API函数来开发(包含头文件pthread.h，需要安装pthread库)，另一种是直接用C++11自带的线程类来开发。
一个进程内的各子线程共享进程内的全局数据。

## **一：POSIX多线程API函数进行多线程开发**

1. 线程创建

```c++
/*
	pid：指向创建成功后的线程ID
	attr：指向线程属性结构体pthread_attr_t的指针，如果为NULL，则使用默认属性
	start_routing：函数指针，指向线程函数，线程创建后将要指向的函数
	arg：指向传给线程函数的参数
	return：如果执行成功返回0
*/
int pthread_create(pthread_t *pid, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
```





## 实际经验

```c
#include <iostream>#include <vector>#include <typeinfo>using namespace std;int main(){    vector<int> vec = { 1,2,3,4,5 };    vector<int>* v = &vec;    (*v).push_back(2);    std::cout << typeid(v).name() << endl;}
```

