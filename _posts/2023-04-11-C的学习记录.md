---
layout: post
read_time: true
show_date: true
title:  C的学习记录
date:   2023-04-11 16:32:20 -0600
description: C的学习记录
img: posts/20230411/datu.jpg 
tags: [C]
author: Geoffrey Hou
category: Coding
mathjax: yes
toc: yes # leave empty or erase for no TOC
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

一些C语言学习记录。

## 9.5 C语言字符串指针（指向字符串的指针）详解

C语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中，这在《[C语言字符数组和字符串](http://c.biancheng.net/view/1832.html)》中已经进行了详细讲解，这里不妨再来演示一下：

```c
#include <stdio.h>
#include <string.h>

int main(){
    char str[] = "http://c.biancheng.net";
    int len = strlen(str), i;
    //直接输出字符串
    printf("%s\n", str);
    //每次输出一个字符
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");
    return 0;
}
```

运行结果：
http://c.biancheng.net
http://c.biancheng.net

字符数组归根结底还是一个数组，上节讲到的关于[指针](http://c.biancheng.net/c/80/)和数组的规则同样也适用于字符数组。更改上面的代码，使用指针的方式来输出字符串：

```c
#include <stdio.h>
#include <string.h>

int main(){
    char str[] = "http://c.biancheng.net";
    char *pstr = str;
    int len = strlen(str), i;

    //使用*(pstr+i)
    for(i=0; i<len; i++){
        printf("%c", *(pstr+i));
    }
    printf("\n");
    //使用pstr[i]
    for(i=0; i<len; i++){
        printf("%c", pstr[i]);
    }
    printf("\n");
    //使用*(str+i)
    for(i=0; i<len; i++){
        printf("%c", *(str+i));
    }
    printf("\n");

    return 0;
}
```

运行结果：
http://c.biancheng.net
http://c.biancheng.net
http://c.biancheng.net

除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串，例如：

```c
char *str = "http://c.biancheng.net";
```

或者：

```c
char *str;str = "http://c.biancheng.net";
```

（**VS2019不能这样了，报错如下图**）

![image-20210827104013366](https://user-images.githubusercontent.com/115327603/231092719-c2fe50aa-bfd0-4fdb-8795-885e3068acdc.png)





字符串中的所有字符在内存中是连续排列的，str 指向的是字符串的第 0 个字符；我们通常将第 0  个字符的地址称为字符串的首地址。字符串中每个字符的类型都是`char`，所以 str 的类型也必须是`char *`。

下面的例子演示了如何输出这种字符串：

```c
#include <stdio.h>
#include <string.h>

int main(){
    char *str = "http://c.biancheng.net";
    int len = strlen(str), i;
   
    //直接输出字符串
    printf("%s\n", str);
    //使用*(str+i)
    for(i=0; i<len; i++){
        printf("%c", *(str+i));
    }
    printf("\n");
    //使用str[i]
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");

    return 0;
}
```

运行结果：
http://c.biancheng.net
http://c.biancheng.net
http://c.biancheng.net

这一切看起来和字符数组是多么地相似，它们都可以使用`%s`输出整个字符串，都可以使用`*`或`[ ]`获取单个字符，这两种表示字符串的方式是不是就没有区别了呢？

*<u>有！它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。</u>*

> 关于全局数据区、栈区、常量区以及其他的内存分区，我们将在《[C语言内存精讲](http://c.biancheng.net/c/140/)》专题中详细讲解，相信你必将有所顿悟，从根本上理解C语言。

内存权限的不同导致的一个明显结果就是，字符数组在定义后可以读取和修改每个字符，而对于第二种形式的字符串，一旦被定义后就只能读取不能修改，任何对它的赋值都是错误的。

我们将第二种形式的字符串称为字符串常量，意思很明显，常量只能读取不能写入。请看下面的演示：

```c
#include <stdio.h>
int main(){
    char *str = "Hello World!";
    str = "I love C!";  //正确
    str[3] = 'P';  //错误

    return 0;
}
```

这段代码能够正常编译和链接，但在运行时会出现段错误（Segment Fault）或者写入位置错误。

第4行代码是正确的，可以更改指针变量本身的指向；第5行代码是错误的，不能修改字符串中的字符。

### 到底使用字符数组还是字符串常量

在编程过程中如果只涉及到对字符串的读取，那么字符数组和字符串常量都能够满足要求；如果有写入（修改）操作，那么只能使用字符数组，不能使用字符串常量。

获取用户输入的字符串就是一个典型的写入操作，只能使用字符数组，不能使用字符串常量，请看下面的代码：

```c
#include <stdio.h>
int main(){
    char str[30];
    gets(str);
    printf("%s\n", str);

    return 0;
}
```

运行结果：
C [C++](http://c.biancheng.net/cplus/) [Java](http://c.biancheng.net/java/) [Python](http://c.biancheng.net/python/) [JavaScript](http://c.biancheng.net/js/)
C C++ Java Python JavaScript

最后我们来总结一下，C语言有两种表示字符串的方法，一种是字符数组，另一种是字符串常量，它们在内存中的存储位置不同，使得字符数组可以读取和修改，而字符串常量只能读取不能修改。

## 9.6 C语言数组灵活多变的访问形式

C语言中的指针使得代码的编写非常灵活，如果指针能够和数组结合，那将会有更多的“花招”，请看下面的代码：

```c
#include <stdio.h>

int main(){
    char str[20] = "c.biancheng.net";
   
    char *s1 = str;
    char *s2 = str+2;
   
    char c1 = str[4];
    char c2 = *str;
    char c3 = *(str+4);
    char c4 = *str+2;
    char c5 = (str+1)[5];
   
    int num1 = *str+2;
    long num2 = (long)str;
    long num3 = (long)(str+2);

    printf("  s1 = %s\n", s1);
    printf("  s2 = %s\n", s2);

    printf("  c1 = %c\n", c1);
    printf("  c2 = %c\n", c2);
    printf("  c3 = %c\n", c3);
    printf("  c4 = %c\n", c4);
    printf("  c5 = %c\n", c5);
   
    printf("num1 = %d\n", num1);
    printf("num2 = %ld\n", num2);
    printf("num3 = %ld\n", num3);

    return 0;
}
```

运行结果：

```c
  s1 = c.biancheng.net
  s2 = biancheng.net
  c1 = a
  c2 = c
  c3 = a
  c4 = e
  c5 = c
num1 = 101
num2 = 2686736
num3 = 2686738
```

怎么样，够晕吧，如果你嗤之以鼻，那么恭喜你，你的C语言基础很扎实。

\1) str 既是数组名称，也是一个指向字符串的指针；指针可以参加运算，加 1 相当于数组下标加 1。

printf() 输出字符串时，要求给出一个起始地址，并从这个地址开始输出，直到遇见字符串结束标志`\0`。s1 为字符串 str 第 0 个字符的地址，s2 为第 2 个字符的地址，所以 printf() 的结果分别为 c.biancheng.net 和 biancheng.net。

\2) 指针可以参加运算，str+4 表示第 4 个字符的地址，c3 = *(str+4) 表示第4个字符，即 'a'。

\3) 其实，数组元素的访问形式可以看做 address[offset]，address 为起始地址，offset 为偏移量：`c1 = str[4]`表示以地址 str 为起点，向后偏移4个字符，为 'a'；`c5 = (str+1)[5]`表示以地址 str+1 为起点，向后偏移5个字符，等价于str[6]，为 'c'。

\4) 字符与整数运算时，先转换为整数（字符对应的ASCII码）。num1 与 c4 右边的表达式相同，对于 num1，*str+2 == 'c'+2 == 99+2 == 101，即 num1 的值为 101，对于 c4，101 对应的字符为 ‘e’，所以 c4 的输出值为 'e'。

\5) num2 和 num3 分别为字符串 str 的首地址和第 2 个元素的地址。

为了加深大家的理解，请继续阅读下面的代码：

```c
#include <stdio.h>
#include <stdlib.h>

int main(){
    char str[20] = {0};
    int i;

    for(i=0; i<10; i++){
        *(str+i) = 97+i;  // 97为字符a的ASCII码值
    }
   
    printf("%s\n", str);
    printf("%s\n", str+2);
    printf("%c\n", str[2]);
    printf("%c\n", (str+2)[2]);
   
    return 0;
}
```

运行结果：

```c
abcdefghij
cdefghij
c
e
```

第5行代码用来将字符数组中的所有元素都初始化为`\0`，这样在循环结束时就无需添加字符串结束标志。

前面三个 printf() 比较容易理解，第四个 printf() 可以参照上面的说明 3)，str+2 表示指向第 2 个元素，(str+2)[2] 相当于 *(str+2+2)，也就是取得第 4 个元素的值。

## 9.7 C语言指针变量作为函数参数

用指针变量作函数参数可以将函数外部的地址传递到函数内部，使得在函数内部可以操作函数外部的数据，并且这些数据不会随着函数的结束而被销毁。

像数组、字符串、动态分配的内存等都是一系列数据的集合，没有办法通过一个参数全部传入函数内部，只能传递它们的指针，在函数内部通过指针来影响这些数据集合。

有的时候，对于整数、小数、字符等基本类型数据的操作也必须要借助指针，一个典型的例子就是交换两个变量的值。

### 用数组作函数参数

数组是一系列数据的集合，无法通过参数将它们一次性传递到函数内部，如果希望在函数内部操作数组，必须传递数组指针。下面的例子定义了一个函数 max()，用来查找数组中值最大的元素：

```c
#include <stdio.h>

int max(int *intArr, int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
   
    return maxValue;
}

int main(){
    int nums[6], i;
    int len = sizeof(nums)/sizeof(int);
    //读取用户输入的数据并赋值给数组元素
    for(i=0; i<len; i++){
        scanf("%d", nums+i);
    }
    printf("Max value is %d!\n", max(nums, len));

    return 0;
}
```

运行结果：
12 55 30 8 93 27↙
Max value is 93!

参数 intArr 仅仅是一个数组指针，在函数内部无法通过这个指针获得数组长度，必须将数组长度作为函数参数传递到函数内部。数组 nums 的每个元素都是整数，scanf() 在读取用户输入的整数时，要求给出存储它的内存的地址，`nums+i`就是第 i 个数组元素的地址。

用数组做函数参数时，参数也能够以“真正”的数组形式给出。例如对于上面的 max() 函数，它的参数可以写成下面的形式：

```c
int max(int intArr[6], int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
    return maxValue;
}
```

`int intArr[6]`好像定义了一个拥有 6 个元素的数组，调用 max() 时可以将数组的所有元素“一股脑”传递进来。

读者也可以省略数组长度，把形参简写为下面的形式：

```c
int max(int intArr[], int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
    return maxValue;
}
```

`int intArr[]`虽然定义了一个数组，但没有指定数组长度，好像可以接受任意长度的数组。

实际上这两种形式的数组定义都是假象，不管是`int intArr[6]`还是`int intArr[]`都不会创建一个数组出来，编译器也不会为它们分配内存，实际的数组是不存在的，它们最终还是会转换为`int *intArr`这样的指针。这就意味着，两种形式都不能将数组的所有元素“一股脑”传递进来，大家还得规规矩矩使用数组指针。

`int intArr[6]`这种形式只能说明函数期望用户传递的数组有 6 个元素，并不意味着数组只能有 6 个元素，真正传递的数组可以有少于或多于 6 个的元素。

需要强调的是，不管使用哪种方式传递数组，都不能在函数内部求得数组长度，因为 intArr 仅仅是一个指针，而不是真正的数组，所以必须要额外增加一个参数来传递数组长度。

C语言为什么不允许直接传递数组的所有元素，而必须传递数组指针呢？

参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。

对于像 int、float、char 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行内存拷贝有可能是一个漫长的过程，会严重拖慢程序的效率，为了防止技艺不佳的程序员写出低效的代码，C语言没有从语法上支持数据集合的直接赋值。

除了C语言，[C++](http://c.biancheng.net/cplus/)、[Java](http://c.biancheng.net/java/)、[Python](http://c.biancheng.net/python/) 等其它语言也禁止对大块内存进行拷贝，在底层都使用类似指针的方式来实现。

## 9.8 C语言指针作为函数返回值

C语言允许函数的返回值是一个[指针](http://c.biancheng.net/c/80/)（地址），我们将这样的函数称为指针函数。下面的例子定义了一个函数 strlong()，用来返回两个字符串中较长的一个：

```c
#include <stdio.h>
#include <string.h>

char *strlong(char *str1, char *str2){
    if(strlen(str1) >= strlen(str2)){
        return str1;
    }else{
        return str2;
    }
}

int main(){
    char str1[30], str2[30], *str;
    gets(str1);
    gets(str2);
    str = strlong(str1, str2);
    printf("Longer string: %s\n", str);

    return 0;
}
```

运行结果：

C Language↙
c.biancheng.net↙
Longer string: c.biancheng.net

***用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据***，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。请看下面的例子：

```c
#include <stdio.h>

int *func(){
    int n = 100;
    return &n;
}

int main(){
    int *p = func(), n;
    n = *p;
    printf("value = %d\n", n);
    return 0;
}
```

运行结果：

value = 100

n 是 func() 内部的局部变量，func() 返回了指向 n 的指针，根据上面的观点，func() 运行结束后 n 将被销毁，使用 *p 应该获取不到 n 的值。但是从运行结果来看，我们的推理好像是错误的，func() 运行结束后 *p 依然可以获取局部变量 n 的值，这个上面的观点不是相悖吗？

为了进一步看清问题的本质，不妨将上面的代码稍作修改，在第9~10行之间增加一个函数调用，看看会有什么效果：

```c
#include <stdio.h>

int *func(){
    int n = 100;
    return &n;
}

int main(){
    int *p = func(), n;
    printf("c.biancheng.net\n");
    n = *p;
    printf("value = %d\n", n);
    return 0;
}
```

运行结果：

c.biancheng.net
value = -2

可以看到，现在 p 指向的数据已经不是原来 n 的值了，它变成了一个毫无意义的甚至有些怪异的值。与前面的代码相比，该段代码仅仅是在 *p 之前增加了一个函数调用，这一细节的不同却导致运行结果有天壤之别，究竟是为什么呢？

前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。

> 关于函数调用的原理以及函数如何占用内存的更多细节，我们将在《[C语言内存精讲](http://c.biancheng.net/c/140/)》专题中深入探讨，相信你必将有所顿悟，解开心中的谜团。

<u>第一个例子在调用其他函数之前使用 *p 抢先获得了 n 的值并将它保存起来，第二个例子显然没有抓住机会，有其他函数被调用后才使用 *p 获取数据，这个时候已经晚了，内存已经被后来的函数覆盖了，而覆盖它的究竟是一份什么样的数据我们无从推断（一般是一个没有意义甚至有些怪异的值）。</u>

## 9.10 C语言空指针NULL以及void指针

### 空指针 NULL

未初始化的局部变量的值是不确定的，C语言并没有对此作出规定，不同的编译器有不同的实现，我曾警告大家不要直接使用未初始化的局部变量。

注意区分大小写，null 没有任何特殊含义，只是一个普通的标识符。

### void 指针

`void *`表示一个有效指针，它确实指向实实在在的数据，只是数据的类型尚未确定，在后续使用过程中一般要进行强制类型转换。

C语言动态内存分配函数 malloc() 的返回值就是`void *`类型，在使用时要进行强制类型转换，请看下面的例子：

```c
#include <stdio.h>

int main(){
    //分配可以保存30个字符的内存，并把返回的指针转换为 char *
    char *str = (char *)malloc(sizeof(char) * 30);
    gets(str);
    printf("%s\n", str);
    return 0;
}
```

运行结果：
c.biancheng.net↙
c.biancheng.net

## 9.11 数组和指针绝不等价，数组是另外一种类型

对，数组也有类型，这是很多读者没有意识到的，大部分C语言书籍对这一点也含糊其辞！我们可以将 int、float、char 等理解为基本类型，将数组理解为由基本类型派生得到的稍微复杂一些的类型。sizeof 就是根据符号的类型来计算长度的。

对于数组 a，它的类型是`int [6]`，表示这是一个拥有 6 个 int 数据的集合，1 个 int 的长度为 4，6 个 int 的长度为 4×6 = 24，sizeof 很容易求得。

对于指针变量 p，它的类型是`int *`，在 32 位环境下长度为 4，在 64 位环境下长度为 8。

归根结底，a 和 p 这两个符号的类型不同，指代的数据也不同，它们不是一码事，sizeof 是根据符号类型来求长度的，a 和 p 的类型不同，求得的长度自然也不一样。

对于二维数组，也是类似的道理，例如`int a[3][3]={1, 2, 3, 4, 5, 6, 7, 8, 9};`，它的类型是`int [3][3]`，长度是 4×3×3 = 36，读者可以亲自测试。

## 9.12 数组到底在什么时候会转换为指针

### 关于数组和指针可交换性的总结

\1) 用 a[i] 这样的形式对数组进行访问总是会被编译器改写成（或者说解释为）像 *(a+i) 这样的指针形式。

\2) 指针始终是指针，它绝不可以改写成数组。你可以用下标形式访问数组，一般都是指针作为函数参数时，而且你知道实际传递给函数的是一个数组。

\3) 在特定的环境中，也就是数组作为函数形参，也只有这种情况，一个数组可以看做是一个指针。作为函数形参的数组始终会被编译器修改成指向数组第一个元素的指针。

\3) 当希望向函数传递数组时，可以把函数参数定义为数组形式（可以指定长度也可以不指定长度），也可以定义为指针。不管哪种形式，在函数内部都要作为指针变量对待。

## 9.16 C语言函数指针（指向函数的指针）详解

一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个[指针](http://c.biancheng.net/c/80/)变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。

函数指针的定义形式为：

```c
returnType (*pointerName)(param list);
```

returnType 为函数返回值类型，pointerName 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。

注意`( )`的优先级高于`*`，第一个括号不能省略，如果写作`returnType *pointerName(param list);`就成了函数原型，它表明函数的返回值类型为`returnType *`。

```c
#include <stdio.h>

//返回两个数中较大的一个
int max(int a, int b){
    return a>b ? a : b;
}

int main(){
    int x, y, maxval;
    //定义函数指针
    int (*pmax)(int, int) = max;  //也可以写作int (*pmax)(int a, int b)
    printf("Input two numbers:");
    scanf("%d %d", &x, &y);
    maxval = (*pmax)(x, y);
    printf("Max value: %d\n", maxval);

    return 0;
}
```

运行结果：
Input two numbers:10 50↙
Max value: 50

第 14 行代码对函数进行了调用。pmax 是一个函数指针，在前面加 * 就表示对它指向的函数进行调用。注意`( )`的优先级高于`*`，第一个括号不能省略。

## 9.18 main()函数的高级用法：接收用户输入的数据

main() 是C语言程序的入口函数，有且只能有一个，它实际上有两种标准的原型：

```c
int main();
int main(int argc, char *argv[]);
```

在第二个原型中，argc 表示传递的字符串的数目（包含输入的可执行文件名*.exe），argv 是一个指针数组，每个指针指向一个字符串（一份数据）。

## 9.19 对C语言指针的总结

|    定  义    |                            含  义                            |
| :----------: | :----------------------------------------------------------: |
|   int *p;    | p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。 |
|   int **p;   |            p 为二级指针，指向 int * 类型的数据。             |
|  int *p[n];  | p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]); |
| int (*p)[n]; |    p 为[二维数组](http://c.biancheng.net/c/array/)指针。     |
|  int *p();   |            p 是一个函数，它的返回值类型为 int *。            |
| int (*p)();  |       p 是一个函数指针，指向原型为 int func() 的函数。       |


\1) 指针变量可以进行加减运算，例如`p++`、`p+i`、`p-=i`。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。

\2) 给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如`int *p = 1000;`是没有意义的，使用过程中一般会导致程序崩溃。

\3) 使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值`NULL`。

\4) 两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数。

\5) 数组也是有类型的，数组名的本意是表示一组类型相同的数据。在定义数组时，或者和 sizeof、& 运算符一起使用时数组名才表示整个数组，表达式中的数组名会被转换为一个指向数组的指针。

## 11.2 C语言const的用法详解，C语言常量定义详解

const 变量称为常量（Cons[tan](http://c.biancheng.net/ref/tan.html)t）。创建常量的格式通常为：

```c
const type name = value;
```

const 和 type 都是用来修饰变量的，它们的位置可以互换，也就是将 type 放在 const 前面：

```c
type const name = value;
```

但我们通常采用第一种方式，不采用第二种方式。另外建议将常量名的首字母大写，以提醒程序员这是个常量。

由于常量一旦被创建后其值就不能再改变，所以常量必须在定义的同时赋值（初始化）.

### const 和[指针](http://c.biancheng.net/c/80/)

```c
const int *p1;
int const *p2;
int * const p3;
```

在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。

```c
const int * const p4;
int const * const p5;
```

指针本身和它指向的数据都有可能是只读的.

*const 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据*。

### const 和函数形参

在C语言中，单独定义 const 变量没有明显的优势，完全可以使用`#define`命令代替。*const 通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 const 来限制。*

### const 和非 const 类型转换

也就是说，`const char *`和`char *`是不同的类型，不能将`const char *`类型的数据赋值给`char *`类型的变量。但反过来是可以的，编译器允许将`char *`类型的数据赋值给`const char *`类型的变量。

这种限制很容易理解，`char *`指向的数据有读取和写入权限，而`const char *`指向的数据只有读取权限，降低数据的权限不会带来任何问题，但提升数据的权限就有可能发生危险。

## 11.3 C语言随机数生成教程，C语言rand和srand用法详解

实际上，rand() 函数产生的随机数是伪随机数，是根据一个数值按照某个公式推算出来的，这个数值我们称之为“种子”。种子和随机数之间的关系是一种正态分布.

使用 <time.h> 头文件中的 time() 函数即可得到当前的时间（精确到秒），就像下面这样：

```c
srand((unsigned)time(NULL));
a = rand() % 51 + 13;
```

# 可变参数

什么是可变参数函数
在C语言编程中有时会遇到一些参数可变的函数，例如printf()、scanf()，其函数原型为：

```c
int printf(const char* format,…)
int scanf(const char *format,…)
```

就拿 printf 来说吧，它除了有一个参数 format 固定以外，后面的参数其个数和类型都是可变的，用三个点“…”作为参数占位符。

参数列表的构成
任何一个可变参数的函数都可以分为两部分：固定参数和可选参数。至少要有一个固定参数，其声明与普通函数参数声明相同；可选参数由于数目不定(0个或以上)，声明时用"…"表示。固定参数和可选参数共同构成可变参数函数的参数列表。

实现原理
C语言中使用 va_list 系列变参宏实现变参函数，此处va意为variable-argument(可变参数)。

x86平台VC6.0编译器中，stdarg.h头文件内变参宏定义如下：

```c
typedef char * va_list;

// 把 n 圆整到 sizeof(int) 的倍数
#define _INTSIZEOF(n)       ( (sizeof(n)+sizeof(int)-1) & ~(sizeof(int)-1) )

// 初始化 ap 指针，使其指向第一个可变参数。v 是变参列表的前一个参数
#define va_start(ap,v)      ( ap = (va_list)&v + _INTSIZEOF(v) )

// 该宏返回当前变参值,并使 ap 指向列表中的下个变参
#define va_arg(ap, type)    ( *(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)) )

// /将指针 ap 置为无效，结束变参的获取
#define va_end(ap)             ( ap = (va_list)0 )

```

_INTSIZEOF(n)
_INTSIZEOF宏考虑到某些系统需要内存地址对齐。从宏名看应按照sizeof(int)即栈粒度对齐，参数在内存中的地址均为sizeof(int)=4的倍数。

例如，若1≤sizeof(n)≤4，则_INTSIZEOF(n)＝4；若5≤sizeof(n)≤8，则_INTSIZEOF(n)=8。

va_start(ap,v)
va_start宏首先根据(va_list)&v得到参数 v 在栈中的内存地址，加上_INTSIZEOF(v)即v所占内存大小后，使 ap 指向 v 的下一个参数。在使用的时候，一般用这个宏初始化 ap 指针，v 是变参列表的前一个参数，即最后一个固定参数，初始化的结果是 ap 指向第一个变参。

va_arg(ap, type)
这个宏取得 type 类型的可变参数值。首先ap += _INTSIZEOF(type)，即 ap 跳过当前可变参数而指向下个变参的地址；然后ap-_INTSIZEOF(type)得到当前变参的内存地址，类型转换后解引用，最后返回当前变参值。

va_end(ap)
va_end 宏使 ap 不再指向有效的内存地址。该宏的某些实现定义为((void*)0)，编译时不会为其产生代码，调用与否并无区别。但某些实现中 va_end 宏用于在函数返回前完成一些必要的清理工作：如 va_start 宏可能以某种方式修改栈，导致返回操作无法完成，va_end 宏可将有关修改复原；又如 va_start 宏可能为参数列表动态分配内存以便于遍历，va_end 宏可释放此内存。因此，从使用 va_start 宏的函数中退出之前，必须调用一次 va_end 宏。

代码示例
变参宏无法智能识别可变参数的数目和类型，因此实现变参函数时需自行判断可变参数的数目和类型。所以我们就要想一些办法，比如

显式提供变参数目或设定遍历结束条件
显式提供变参类型枚举值，或在固定参数中包含足够的类型信息(如printf函数通过分析format字符串即可确定各变参类型)
主调函数和被调函数可约定变参的数目和类型
…
例1：**函数通过固定参数指定可变参数个数**，打印所有变参值。

```c
#include <stdarg.h>
#include <stdio.h>

void parse_valist_by_num(int arg_cnt, ...);

int main(void)
{
    parse_valist_by_num(4,1,2,3,4);
    parse_valist_by_num(4,1,2,3); 
    parse_valist_by_num(4,1,2,3,4,5); //多余的变参被忽略
}


//第一个参数定义可变参数的个数
void parse_valist_by_num(int arg_cnt, ...)
{
    
    va_list p_args;
    va_start(p_args, arg_cnt);
    
    int idx;
    int val;
    
    for(idx = 1; idx <= arg_cnt; ++idx){
        val = va_arg(p_args, int);
        printf("第 %d 个参数: %d\n", idx, val);
    }
    printf("---------------\n");
    va_end(p_args);
}

```

注意第2个结果，第4个参数是一个魔数

例2：**函数定义一个结束标记(-1)，调用时通过最后一个参数传递该标记**，打印标记前所有变参值。

```c
#include <stdarg.h>
#include <stdio.h>

void parse_valist_by_flag(int num_1, ...);

int main(void)
{
    parse_valist_by_flag(1,-1);
    parse_valist_by_flag(1,2,3,5,-1);
    parse_valist_by_flag(-1);
    
}

//函数定义一个结束标记(-1)，调用时通过最后一个参数传递该标记，以结束变参的遍历打印。
//最后一个参数作为变参结束符(-1)，用于循环获取变参内容
void parse_valist_by_flag(int num_1, ...)
{
    va_list p_args;
    va_start(p_args, num_1);
    int idx = 0;
    int val = num_1;
    while(val != -1){
        ++idx;
        printf("第 %d 个参数: %d\n", idx, val);
        val = va_arg(p_args, int); //得到下个变参值
    }
    va_end(p_args);
    printf("---------------\n");
}

```

**需要注意**
**va_arg(ap, type)宏中的 type 不可指定为以下类型：**

**char**
**short**
**float**
在C语言中，调用不带原型声明或声明为变参的函数时，主调函数会在传递未显式声明的参数前对其执行缺省参数提升(default argument promotions)，将提升后的参数值传递给被调函数。

 提升操作如下：

float 类型的参数提升为 double 类型
char、short 和相应的 signed、unsigned 类型参数提升为 int 类型
若 int 类型不能容纳原值，则提升为 unsigned int 类型
最后来一张图，帮助大家理解前文讲的宏。

![img](https://img-blog.csdnimg.cn/20181231224339823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0OTA4OTY=,size_16,color_FFFFFF,t_70)

# 库函数

## string.h

|                          函数                           |                       说明                        |
| :-----------------------------------------------------: | :-----------------------------------------------: |
|   [bcmp()](http://c.biancheng.net/cpp/html/148.html)    |        比较内存(字符串)的前n个字节是否相等        |
|   [bcopy()](http://c.biancheng.net/cpp/html/149.html)   |                 复制内存(字符串)                  |
|   [bzero()](http://c.biancheng.net/cpp/html/150.html)   |           将内存（字符串）前n个字节清零           |
|  [memcpy()](http://c.biancheng.net/cpp/html/155.html)   |               复制内存内容(忽略\0)                |
|  [memmove()](http://c.biancheng.net/cpp/html/156.html)  |       复制内存内容（可以处理重叠的内存块）        |
|  [memset()](http://c.biancheng.net/cpp/html/157.html)   |          将内存的前n个字节设置为特定的值          |
|  [strcat()](http://c.biancheng.net/cpp/html/160.html)   |                    连接字符串                     |
|  [strchr()](http://c.biancheng.net/cpp/html/161.html)   |        查找某字符在字符串中首次出现的位置         |
|  [strcmp()](http://c.biancheng.net/cpp/html/162.html)   |             比较字符串（区分大小写）              |
|  [strcoll()](http://c.biancheng.net/cpp/html/163.html)  |        根据环境变量LC_COLLATE来比较字符串         |
|  [strcspn()](http://c.biancheng.net/cpp/html/165.html)  | 计算字符串str中连续有几个字符都不属于字符串accept |
|  [strlen()](http://c.biancheng.net/cpp/html/167.html)   |                 返回字符串的长度                  |
|  [strncat()](http://c.biancheng.net/cpp/html/169.html)  |             在字符串的结尾追加n个字符             |
|  [strncpy()](http://c.biancheng.net/cpp/html/170.html)  |               复制字符串的前n个字符               |
|  [strpbrk()](http://c.biancheng.net/cpp/html/171.html)  |        返回两个字符串中首个相同字符的位置         |
|  [strrchr()](http://c.biancheng.net/cpp/html/172.html)  |      查找某字符在字符串中最后一次出现的位置       |
|  [strspn()](http://c.biancheng.net/cpp/html/173.html)   |  计算字符串str中连续有几个字符都属于字符串accept  |
|  [strstr()](http://c.biancheng.net/cpp/html/174.html)   |          返回字符串中首次出现子串的地址           |
|  [strtok()](http://c.biancheng.net/cpp/html/175.html)   |                    字符串分割                     |
|  [stpcpy()](http://c.biancheng.net/cpp/html/2539.html)  |                将字符串复制到数组                 |
|  [strcpy()](http://c.biancheng.net/cpp/html/2540.html)  |                    字符串复制                     |
| [stricmp()](http://c.biancheng.net/cpp/html/2713.html)  |            比较字符串（不区分大小写）             |
| [strcmpi()](http://c.biancheng.net/cpp/html/2714.html)  |    比较字符串(不区分大小写)，stricmp()的宏定义    |
|  [strlwr()](http://c.biancheng.net/cpp/html/2715.html)  |                将字符串转换为小写                 |
|  [strupr()](http://c.biancheng.net/cpp/html/2716.html)  |                将字符串转换为大写                 |
| [strncmp()](http://c.biancheng.net/cpp/html/2717.html)  |        比较字符串的前n个字符（区分大小写）        |
| [strnicmp()](http://c.biancheng.net/cpp/html/2718.html) |        比较字符串的前n个字符（区分大小写）        |
| [strncmpi()](http://c.biancheng.net/cpp/html/2719.html) |     比较两个字符串的前n个字符（不区分大小写）     |
|  [strrev()](http://c.biancheng.net/cpp/html/2721.html)  |             字符串逆置（倒序、逆序）              |
|  [strset()](http://c.biancheng.net/cpp/html/2722.html)  |         将字符串的所有字符设置为指定字符          |
| [strnset()](http://c.biancheng.net/cpp/html/2723.html)  |         将字符串的前n个字符设置为指定字符         |



## ctype.h

|                          函数                          |                 说明                 |
| :----------------------------------------------------: | :----------------------------------: |
| [isalnum()](http://c.biancheng.net/cpp/html/112.html)  |     判断字符是否为英文字母或数字     |
| [isalpha()](http://c.biancheng.net/cpp/html/113.html)  |        判断字符是否为英文字母        |
| [iscntrl()](http://c.biancheng.net/cpp/html/115.html)  |   判断字符是否为ASCII码的控制字符    |
| [isdigit()](http://c.biancheng.net/cpp/html/116.html)  |       判断字符是否为阿拉伯数字       |
| [isgraph()](http://c.biancheng.net/cpp/html/117.html)  | 判断字符是否为除空格以外的可打印字符 |
| [islower()](http://c.biancheng.net/cpp/html/118.html)  |        判断字符是否为小写字母        |
| [isprint()](http://c.biancheng.net/cpp/html/119.html)  |       判断字符是否为可打印字符       |
| [isspace()](http://c.biancheng.net/cpp/html/120.html)  |        判断字符是否为空白字符        |
| [ispunct()](http://c.biancheng.net/cpp/html/121.html)  |   判断字符是否为标点符号或特殊字符   |
| [isupper()](http://c.biancheng.net/cpp/html/122.html)  |      判断字符是否为大写英文字母      |
| [isxdigit()](http://c.biancheng.net/cpp/html/123.html) |       判断字符是否为16进制数字       |
| [toascii()](http://c.biancheng.net/cpp/html/131.html)  |      将字符转换成对应的ASCII码       |
| [tolower()](http://c.biancheng.net/cpp/html/132.html)  |       将大写字母转换为小写字母       |
| [toupper()](http://c.biancheng.net/cpp/html/133.html)  |       将小写字母转换为大写字母       |
| [isascii()](http://c.biancheng.net/cpp/html/2534.html) |       检测字符是否为ASCII字符        |
| [isblank()](http://c.biancheng.net/cpp/html/2535.html) |       判断字符是否为TAB或空格        |

## math.h

|                         函数                         |                 说明                 |
| :--------------------------------------------------: | :----------------------------------: |
|  [acos()](http://c.biancheng.net/cpp/html/177.html)  |             求反余弦的值             |
|  [cos()](http://c.biancheng.net/cpp/html/182.html)   |               求余弦值               |
|  [cosh()](http://c.biancheng.net/cpp/html/183.html)  |             求双曲余玄值             |
|  [exp()](http://c.biancheng.net/cpp/html/184.html)   |    e的次幂函数(以e为底的x次方值)     |
| [frexp()](http://c.biancheng.net/cpp/html/185.html)  |     把一个浮点数分解为尾数和指数     |
| [ldexp()](http://c.biancheng.net/cpp/html/186.html)  |       返回x乘上2的exp次方的值        |
|  [log()](http://c.biancheng.net/cpp/html/187.html)   |         返回以e为底的对数值          |
| [log10()](http://c.biancheng.net/cpp/html/188.html)  |         返回以10为底的对数值         |
|  [pow()](http://c.biancheng.net/cpp/html/189.html)   |          求x的y次方（次幂）          |
|  [sin()](http://c.biancheng.net/cpp/html/190.html)   |               正弦函数               |
|  [sinh()](http://c.biancheng.net/cpp/html/191.html)  |             双曲正玄函数             |
|  [sqrt()](http://c.biancheng.net/cpp/html/192.html)  |           求给定值的平方根           |
|  [tan()](http://c.biancheng.net/cpp/html/193.html)   |               正切函数               |
|  [tanh()](http://c.biancheng.net/cpp/html/194.html)  |            双曲线正切函数            |
| [fabs()](http://c.biancheng.net/cpp/html/2523.html)  |           求浮点数的绝对值           |
|  [abs()](http://c.biancheng.net/cpp/html/2524.html)  |            求整数的绝对值            |
| [asin()](http://c.biancheng.net/cpp/html/2525.html)  |              反正弦函数              |
| [atan()](http://c.biancheng.net/cpp/html/2526.html)  |              反正切函数              |
| [atan2()](http://c.biancheng.net/cpp/html/2527.html) |           求y/x的反正切值            |
| [ceil()](http://c.biancheng.net/cpp/html/2528.html)  | 向上取整，即求不小于某个数的最小整数 |
| [floor()](http://c.biancheng.net/cpp/html/2529.html) | 向下取整，即求不大于某个数的最大整数 |
| [fmod()](http://c.biancheng.net/cpp/html/2530.html)  |         对浮点数取模（求余）         |
| [modf()](http://c.biancheng.net/cpp/html/2531.html)  |     将浮点数分解为整数和小数部分     |
| [hypot()](http://c.biancheng.net/cpp/html/2532.html) |         求直角三角形的斜边长         |
| [pow10()](http://c.biancheng.net/cpp/html/2533.html) |         求10的x次方（次幂）          |

## stdlib.h

|                          函数                          |                    说明                     |
| :----------------------------------------------------: | :-----------------------------------------: |
|   [atof()](http://c.biancheng.net/cpp/html/124.html)   |     将字符串转换为double(双精度浮点数)      |
|   [atoi()](http://c.biancheng.net/cpp/html/125.html)   |           将字符串转换成int(整数)           |
|   [atol()](http://c.biancheng.net/cpp/html/126.html)   |         将字符串转换成long(长整型)          |
|  [strtod()](http://c.biancheng.net/cpp/html/128.html)  |     将字符串转换为double(双精度浮点数)      |
|  [strtol()](http://c.biancheng.net/cpp/html/129.html)  |        将字符串转换成long(长整型数)         |
| [strtoul()](http://c.biancheng.net/cpp/html/130.html)  | 将字符串转换成unsigned long(无符号长整型数) |
|  [calloc()](http://c.biancheng.net/cpp/html/134.html)  |            分配内存空间并初始化             |
|   [free()](http://c.biancheng.net/cpp/html/135.html)   |           释放动态分配的内存空间            |
|  [malloc()](http://c.biancheng.net/cpp/html/137.html)  |              动态分配内存空间               |
| [realloc()](http://c.biancheng.net/cpp/html/2859.html) |              重新分配内存空间               |

## stdio.h

|                          函数                           |                        说明                         |
| :-----------------------------------------------------: | :-------------------------------------------------: |
|   [fopen()](http://c.biancheng.net/cpp/html/250.html)   |             打开一个文件并返回文件指针              |
|   [getc()](http://c.biancheng.net/cpp/html/258.html)    |                   从流中读取字符                    |
|  [getchar()](http://c.biancheng.net/cpp/html/259.html)  |             从控制台读取字符并立即回显              |
|   [gets()](http://c.biancheng.net/cpp/html/260.html)    |                  从流中读取字符串                   |
|   [putc()](http://c.biancheng.net/cpp/html/262.html)    |         写文件函数(将一指定字符写入文件中)          |
|  [putchar()](http://c.biancheng.net/cpp/html/263.html)  |                向控制台输出一个字符                 |
|  [rewind()](http://c.biancheng.net/cpp/html/264.html)   |             将文件指针重新指向文件开头              |
|  [setbuf()](http://c.biancheng.net/cpp/html/265.html)   |                 把缓冲区与流相关联                  |
|  [setvbuf()](http://c.biancheng.net/cpp/html/268.html)  |                 设置文件流的缓冲区                  |
|  [ungetc()](http://c.biancheng.net/cpp/html/269.html)   |                 把字符退回到输入流                  |
|  [printf()](http://c.biancheng.net/cpp/html/293.html)   |                   格式化输出函数                    |
|  [sprintf()](http://c.biancheng.net/cpp/html/295.html)  |              将格式化的数据写入字符串               |
|  [sscanf()](http://c.biancheng.net/cpp/html/296.html)   |            从字符串中读取指定格式的数据             |
|  [remove()](http://c.biancheng.net/cpp/html/322.html)   |                   删除文件或目录                    |
|  [rename()](http://c.biancheng.net/cpp/html/323.html)   |                  重命名文件或目录                   |
|  [perror()](http://c.biancheng.net/cpp/html/347.html)   |              打印最近一次系统错误信息               |
|  [getche()](http://c.biancheng.net/cpp/html/2409.html)  |             从控制台读取字符并立即回显              |
|   [getw()](http://c.biancheng.net/cpp/html/2410.html)   |           以二进制形式从文件流中读取整数            |
|   [puts()](http://c.biancheng.net/cpp/html/2411.html)   |        将一个字符串放入标准输出流(stdout)中         |
|   [putw()](http://c.biancheng.net/cpp/html/2412.html)   |           以二进制形式向文件流中写入整数            |
| [snprintf()](http://c.biancheng.net/cpp/html/2417.html) |         将格式化的数据写入字符串—sprintf()          |
| [temfile()](http://c.biancheng.net/cpp/html/2418.html)  |         以二进制形式创建一个临时文件并打开          |
|  [tmpnam()](http://c.biancheng.net/cpp/html/2419.html)  |           产生一个唯一的包含路径的文件名            |
| [ungetch()](http://c.biancheng.net/cpp/html/2420.html)  |             把一个字符退回到键盘缓冲区              |
| [fgetpos()](http://c.biancheng.net/cpp/html/2421.html)  |               获得当前文件的读写指针                |
| [fsetpos()](http://c.biancheng.net/cpp/html/2422.html)  |               设置当前文件的读写指针                |
|  [fclose()](http://c.biancheng.net/cpp/html/2505.html)  |                     关闭文件流                      |
|  [fflush()](http://c.biancheng.net/cpp/html/2506.html)  |       清空文件缓冲区（或标准输入输出缓冲区）        |
|  [ferror()](http://c.biancheng.net/cpp/html/2507.html)  |                 检测文件流是否出错                  |
| [freopen()](http://c.biancheng.net/cpp/html/2508.html)  |                文件流重定向，流替换                 |
| [clearerr()](http://c.biancheng.net/cpp/html/2509.html) | 清除（复位）文件流的错误标识，并使文件结束标标识为0 |
|  [fgetc()](http://c.biancheng.net/cpp/html/2510.html)   |               从文件流中读取一个字符                |
| [fgetchar()](http://c.biancheng.net/cpp/html/2511.html) |               从文件流中读取一个字符                |
| [fputchar()](http://c.biancheng.net/cpp/html/2512.html) |        将一个字符输出到标准输出流(stdout)中         |
|  [fgets()](http://c.biancheng.net/cpp/html/2513.html)   |         从文件流中读取一行或指定个数的字符          |
|   [feof()](http://c.biancheng.net/cpp/html/2514.html)   |      检查流上文件的结束标识(是否读到文件结尾)       |
|  [fputs()](http://c.biancheng.net/cpp/html/2515.html)   |             将指定的字符串写入到文件流              |
|  [fread()](http://c.biancheng.net/cpp/html/2516.html)   |                 从文件流中读取数据                  |
|  [fwrite()](http://c.biancheng.net/cpp/html/2517.html)  |                 向文件流中写入数据                  |
|  [fseek()](http://c.biancheng.net/cpp/html/2518.html)   |           移动文件的读写指针到指定的位置            |
|  [ftell()](http://c.biancheng.net/cpp/html/2519.html)   |             获取文件读写指针的当前位置              |
| [fprintf()](http://c.biancheng.net/cpp/html/2520.html)  |              将格式化数据输出到文件流               |
|  [scanf()](http://c.biancheng.net/cpp/html/2521.html)   |                   格式化输入函数                    |
|  [fscanf()](http://c.biancheng.net/cpp/html/2522.html)  |             将文件流中的数据格式化输入              |

# cppreference.com

## strcoll--根据本地化的字符串比较

[strcoll - cppreference.com](https://en.cppreference.com/w/c/string/byte/strcoll)

## strspn--检索str1中第一个不在str2中出现的字符下标

[strspn - cppreference.com](https://en.cppreference.com/w/c/string/byte/strspn)

[C 库函数 – strspn() | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-function-strspn.html)

可以获得初始段匹配长度。

## strcspn--检索**str1** 开头连续有几个字符都不含 **str2** 中的字符

[strcspn - cppreference.com](https://en.cppreference.com/w/c/string/byte/strcspn)

[C 库函数 – strcspn() | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-function-strcspn.html)

可以获取第一个匹配字符的位置。

## strpbrk

[strpbrk - cppreference.com](https://en.cppreference.com/w/c/string/byte/strpbrk)

[C 库函数 – strpbrk() | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-function-strpbrk.html)

## strtok--分解字符串 **str** 为一组字符串，**delim** 为分隔符

[strtok, strtok_s - cppreference.com](https://en.cppreference.com/w/c/string/byte/strtok)

[C 库函数 – strtok() | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-function-strtok.html)

```c
char *strtok(char *str, const char *delim)
```

```c
#include <string.h>
#include <stdio.h>
 
int main () {
   char str[80] = "This is - www.runoob.com - website";
   const char s[2] = "-";
   char *token;
   
   /* 获取第一个子字符串 */
   token = strtok(str, s);
   
   /* 继续获取其他的子字符串 */
   while( token != NULL ) {
      printf( "%s\n", token );
    
      token = strtok(NULL, s);
   }
   
   return(0);
}
```

特别要注意分割处理后原字符串 str的改动是切分符原位置均更改为 **'\0'**.

- If `str` is a null pointer, the call is treated as a subsequent calls to `strtok`: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as str.

## memchr--字符串的前 **n** 个字节中搜索第一次出现字符 **c**

[memchr - cppreference.com](https://en.cppreference.com/w/c/string/byte/memchr)

[C 库函数 – memchr() | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-function-memchr.html)

## memccpy

[memccpy - cppreference.com](https://en.cppreference.com/w/c/string/byte/memccpy)

```c
void *memccpy(void * restrict dest, const void * restrict src, int c, size_t count);
```

## mktime

[mktime - cppreference.com](https://en.cppreference.com/w/c/chrono/mktime)

[C 库函数 – mktime() | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-function-mktime.html)

**time_t mktime(struct tm \*timeptr)** 把 **timeptr** 所指向的结构转换为自 1970 年 1 月 1 日以来持续时间的秒数，发生错误时返回-1。

## struct tm

```c
struct tm {
   int tm_sec;         /* 秒，范围从 0 到 59                */
   int tm_min;         /* 分，范围从 0 到 59                */
   int tm_hour;        /* 小时，范围从 0 到 23                */
   int tm_mday;        /* 一月中的第几天，范围从 1 到 31                    */
   int tm_mon;         /* 月份，范围从 0 到 11                */
   int tm_year;        /* 自 1900 起的年数                */
   int tm_wday;        /* 一周中的第几天，范围从 0 到 6                */
   int tm_yday;        /* 一年中的第几天，范围从 0 到 365                    */
   int tm_isdst;       /* 夏令时                        */    
};
```

## strftime

[C 库函数 – strftime() | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-function-strftime.html)

## abort

[abort - cppreference.com](https://en.cppreference.com/w/c/program/abort)

## exit

[exit - cppreference.com](https://en.cppreference.com/w/c/program/exit)

## _Exit

[_Exit - cppreference.com](https://en.cppreference.com/w/c/program/_Exit)

## atexit

[atexit - cppreference.com](https://en.cppreference.com/w/c/program/atexit)

## at_quick_exit

[at_quick_exit - cppreference.com](https://en.cppreference.com/w/c/program/at_quick_exit)

## setjmp--跨函数跳转

[setjmp - cppreference.com](https://en.cppreference.com/w/c/program/setjmp)

[C 库宏 – setjmp() | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-macro-setjmp.html)



















# RUNOOB

## time.h

### 几个时间概念：

**1：Coordinated Universal Time(UTC)：**

协调世界时，又称世界标准时间，也即格林威治标准时间(Greenwich Mean Time,GMT)，中国内地的时间与UTC得时差为+8，也即UTC+8，美国为UTC-5。

**2：Calendar Time：**

日历时间，是用"从一个标准时间点到此时的时间经过的秒数"来表示的时间。标准时间点对不同编译器可能会不同，但对一个编译系统来说，标准时间是不变的。一般是表示距离UTC时间 1970-01-01 00:00:00的秒数。

**3：epoch：**

时间点。在标准c/c++中是一个整数，用此时的时间和标准时间点相差的秒数（即日历时间）来表示。

**4：clock tick：**

时钟计时单元（而不叫做时钟滴答次数），一个时钟计时单元的时间长短是由cpu控制的，一个clock tick不是cpu的一个时钟周期，而是c/c++的一个基本计时单位。

## time.h 的定义

time.h 头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数。

### 4个变量

| size_t    | 是无符号整数类型，它是 sizeof 关键字的结果。          |
| :-------- | :---------------------------------------------------- |
| clock_t   | 这是一个适合存储处理器时间的类型，类型为unsigned long |
| time_t    | 这是一个适合存储日历时间类型。                        |
| struct tm | 这是一个用来保存时间和日期的结构。                    |

tm 结构的定义如下：

struct tm
{
  int tm_sec;     */\* 秒，范围从 0 到 59    \*/*
  int tm_min;     */\* 分，范围从 0 到 59    \*/*
  int tm_hour;     */\* 小时，范围从 0 到 23   \*/*
  int tm_mday;     */\* 一月中的第几天，范围从 1 到 31   \*/*
  int tm_mon;     */\* 月，范围从 0 到 11(注意)  \*/*
  int tm_year;     */\* 自 1900 年起的年数    \*/*
  int tm_wday;     */\* 一周中的第几天，范围从 0 到 6 \*/*
  int tm_yday;     */\* 一年中的第几天，范围从 0 到 365  \*/*
  int tm_isdst;    */\* 夏令时        \*/*
};

### 两个宏

| NULL           | 这个宏是一个空指针常量的值。                                 |
| :------------- | :----------------------------------------------------------- |
| CLOCKS_PER_SEC | 这个宏表示每秒的处理器时钟个数。用于将clock()函数的结果转化为以秒为单位的量，这个量的具体值是与操作系统相关的，通常为1000。 |

## 库函数

### 1：clock函数

函数原型： **clock_t clock(void)**

函数返回：返回clock函数执行起（一般为程序的开头），处理器时钟所使用的时间。

函数功能：用来计算程序或程序的某一段的执行时间。

## 实例

```c
#include<stdio.h>
#include<time.h>

int main()
{
  clock_t start_t,finish_t;
  double total_t = 0;
  int i = 0;
  start_t = clock();
  for(;i<100000;++i)
  {
    *//do someting;*
  }
  finish_t = clock();
  total_t = (double)(finish_t - start_t) / CLOCKS_PER_SEC;*//将时间转换为秒*

  printf("CPU 占用的总时间：%f**\n**", total_t);
  return 0;
}
```

### 2：time函数

函数原型: time_t time(time_t *timer)

参数说明: timer=NULL时得到当前日历时间（从1970-01-01 00:00:00到现在的秒数），timer=时间数值时，用于设置日历时间，time_t是一个unsigned long类型。如果 timer不为空，则返回值也存储在变量 timer中。

函数功能: 得到当前日历时间或者设置日历时间

函数返回: 当前日历时间

## 实例

```c
#include <stdio.h>
#include <time.h>

int main ()
{
 time_t seconds;

 seconds = time(NULL);
 printf("自 1970-01-01 起的小时数 = %ld**\n**", seconds/3600);

 return(0);
}
```

### 3：asctime函数

函数原型: char* asctime(struct tm * ptr)

函数功能:将结构struct tm * ptr所表示的时间以字符串表示

函数返回: 返回的时间字符串格式为：星期,月,日,小时:分:秒,年

参数说明: 结构指针ptr应通过函数localtime()或gmtime()得到

## 实例

```c
#include <stdio.h>
#include <time.h>

int main()
{
  struct tm t;//更多情况下是通过localtime函数及gmtime函数获得tm结构*

  t.tm_sec   = 10;
  t.tm_min   = 10;
  t.tm_hour  = 6;
  t.tm_mday  = 25;
  t.tm_mon   = 2;
  t.tm_year  = 89;
  t.tm_wday  = 6;

  printf("%s\n",asctime(&t));

  return(0);
}
```

### 4：localtime函数

函数原型: struct tm *localtime(const time_t *timer)

函数功能: 使用 timer 的值来填充 tm 结构。timer 的值被分解为 tm 结构，并用本地时区表示。

函数返回: 以tm结构表达的时间

```c
#include <stdio.h>
#include <time.h>

int main ()
{
   time_t timer;
   struct tm *Now;

   time( &timer );
   Now = localtime( &timer );
   printf("当前的本地时间和日期：%s", asctime(Now));

   return(0);
}
```

### 5：ctime函数

函数原型: char *ctime(const time_t * timer)

函数功能: 将日历时间参数timer转换为一个表示本地当前时间的字符串

函数返回: 返回字符串格式：星期,月,日,小时:分:秒,年

参数说明: timer参数应由函数time获得，其等价于 astime( localtime(timer) )

```c
#include <stdio.h>
#include <time.h>

int main ()
{
   time_t curtime;
   time(&curtime);
   printf("当前时间 = %s", ctime(&curtime));

   return(0);
}
```

### 6：difftime函数

函数原型: double difftime(time_t time2, time_t time1)

函数功能: 得到两次机器时间差，单位为秒

函数返回: 时间差，单位为秒

参数说明: time1,time2分别表示两个不同的机器时间，该参数应使用time函数获得

```c
#include <time.h>  
#include <stdio.h>  
int main()  
{  
    time_t first,second;  
    time(&first);  
    sleep(2000);  
    time(&second);
    printf("The difference is: %f seconds",difftime(second,first));  

    return 0;  
}  
```

### 7：gmtime函数

函数原型: struct tm *gmtime(time_t *timer)

函数功能: 得到以结构tm表示的时间信息，并用格林威治标准时间表示

函数返回: 以结构tm表示的时间信息指针

参数说明: timer用函数time()得到的时间信息

```c
#include <stdio.h>
#include <time.h>

#define BST (+1)
#define CCT (+8)

int main ()
{

   time_t rawtime;
   struct tm *info;

   time(&rawtime);
   /* 获取 GMT 时间 */
   info = gmtime(&rawtime );

   printf("当前的世界时钟：\n");
   printf("伦敦：%2d:%02d\n", (info->tm_hour+BST)%24, info->tm_min);
   printf("中国：%2d:%02d\n", (info->tm_hour+CCT)%24, info->tm_min);

   return(0);
}
```

### 8：mktime函数

函数原型：time_t mktime(struct tm *timeptr)

函数功能：把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值

函数返回：该函数返回一个 time_t 值，该值对应于以参数传递的日历时间。如果发生错误，则返回 -1 值。

```c
#include <stdio.h>
#include <time.h>

int main ()
{
   int ret;
   struct tm info;
   char buffer[80];

   info.tm_year = 2001 - 1900;
   info.tm_mon = 7 - 1;
   info.tm_mday = 4;
   info.tm_hour = 0;
   info.tm_min = 0;
   info.tm_sec = 1;
   info.tm_isdst = -1;

   ret = mktime(&info);
   if( ret == -1 )
   {
       printf("错误：不能使用 mktime 转换时间。\n");
   }
   else
   {
      strftime(buffer, sizeof(buffer), "%c", &info );
      print(buffer);
   }

   return(0);
}
```

### 9：strftime函数

函数原型: size_t strftime( char *strDest, size_t maxsize, const char *format, const struct tm *timeptr);

函数功能: 根据format指向字符串中格式命令把timeptr中保存的时间信息放在strDest指向的字符串中，最多向 strDest中存放maxsize个字符。

参数说明: 转化结果存在s中，最多maxsize个字符写到s中

函数返回: 该函数返回向strDest指向的字符串中放置的字符数（不包括'\0'），如果字符数多于maxsize，函数返回0。

```c
/*format如下：它们是区分大小写的。
    %a 星期几的简写
    %A 星期几的全称
    %b 月分的简写
    %B 月份的全称
    %c 标准的日期的时间串
    %C 年份的后两位数字
    %d 十进制表示的每月的第几天
    %D 月/天/年
    %e 在两字符域中，十进制表示的每月的第几天
    %F 年-月-日
    %g 年份的后两位数字，使用基于周的年
    %G 年分，使用基于周的年
    %h 简写的月份名
    %H 24小时制的小时
    %I 12小时制的小时
    %j 十进制表示的每年的第几天
    %m 十进制表示的月份
    %M 十时制表示的分钟数
    %n 新行符
    %p 本地的AM或PM的等价显示
    %r 12小时的时间
    %R 显示小时和分钟：hh:mm
    %S 十进制的秒数
    %t 水平制表符
    %T 显示时分秒：hh:mm:ss
    %u 每周的第几天，星期一为第一天 （值从0到6，星期一为0）
    %U 第年的第几周，把星期日做为第一天（值从0到53）
    %V 每年的第几周，使用基于周的年
    %w 十进制表示的星期几（值从0到6，星期天为0）
    %W 每年的第几周，把星期一做为第一天（值从0到53）
    %x 标准的日期串
    %X 标准的时间串
    %y 不带世纪的十进制年份（值从0到99）
    %Y 带世纪部分的十进制年份
    %z，%Z 时区名称，如果不能得到时区名称则返回空字符。
    %% 百分号
*/  

#include <stdio.h>
#include <time.h>

int main ()
{
   time_t rawtime;
   struct tm *info;
   char buffer[80];

   time( &rawtime );

   info = localtime( &rawtime );

   strftime(buffer,80,"%Y%m%e_%H%M%S", info);//以年月日_时分秒的形式表示当前时间
   printf("%s\n", buffer );

   return(0);
}
```

































# 实际经验

## 从字符串中取出数字

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main(int argc, char* argv[])
{
    int num = 0;
    char* str = (char*)"dsds12456.";
    char* cur = str;
    for(int i = 0; i < strlen(str); i++)
    {
        if((*cur >= '0') && (*cur <= '9'))
        {
            num = num * 10 + *cur - '0';
        }
        cur++;
    }
    
    return 0;
}
```

### 封装函数

#### 将不连续的数字取为一个数

如ffdfd32ffg545，输出为32545

```c
int getNumInString(const char* str)
{
    char* cur = (char*)str;
    int num = 0;
    for(int i = 0; o < strlen(str); i++)
    {
        if((*cur >= '0') && (*cur <= '9'))
        {
            num = num * 10 + *cur - '0';
        }
        cur++;
    }
    return num;
}
```

#### 取出字符串中的第一个数

```c
int get1stNumInString(const char* str)
{
    char* cur = (char*)str;
    int num = 0， flag = 0;
    for(int i = 0; i < strlen(str); i++)
    {
        if((*cur >= '0') && (*cur <= '9'))
        {
            num = num * 10 + *cur - '0';
            flag = 1;
        }
        cur++;
        if((1 == flag) && ((*cur < '0') || (*cur > '9')))
        {
            break;
        }
    }
    return num;
}
```

#### 取出字符串中所有的数字

```c
int getAllNumString(const char* str, int* res)
{
    int num = 0， flag = 0, cnt = 0;
    char* cur = (char*)str;
    for(int i = 0; o < strlen(str); i++)
    {
        if((*cur >= '0') && (*cur <= '9'))
        {
            num = num * 10 + *cur - '0';
            flag = 1;
        }
        cur++;
        if((1 == flag) && ((*cur < '0') || (*cur > '9')))
        {
            break;
        }
    }
    return res;
}
```



## 新建文件夹

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <direct.h>
int main(int argc, char* argv[])
{
    char* fileName = (char*)malloc(20);
    itoa(num, filename, 10);
    if(_access(fileName, 0) == -1)
    {
        mkdir(fileName);//这里可以配置不同权限，linux下要注意，否则没有权限
    }
    free(fileName);
    
    return 0;
}
```

## %x的打印

%x只能打印32bit数据，如果超过，只能一个一个取出来再打印。例如十六进制数AAAABBBBC，对应十进制为45813054396，想要按照十六进制打印，如下：

```c
#define _ULONG64 (unsigned long long)
int main(int argc, char* argv[])
{
    _ULONG64 temp = 45813054396;
    int arr[9];
    for(int i = 0; i < 9; i++)
    {
        arr[i] = (temp >> 4*i) & 0xF;
    }
    for(int i = 8; i >)
}
```

## malloc后一定要memset初始化

## malloc后一定要free或者realloc

## linux直接读取64bit整数不对

windows和linux从txt读取一个64bit的数据，linux会有大概一半数据不对。只能按照字符串读出来，然后解析。

## C++的string不能用printf打印

要用c_str()转换成C风格才能用printf，或者用cout输出（否则会乱码）。例如

```c
String s="Hello World!";

printf("%s\n",s);

               （1）使用s的首地址：printf("%s\n",s.c_str());

               （2）使用cout<<s<<endl;输出。
```

## mod的高效算法

计算对K mod $$2^n$$取模时，高效算法是K & $$2^n-1$$。

以9 mod 8 = 1为例，1001 mod 1000 = 1，1001 & 0111 = 1。发现：$$2^n$$的二进制只有最高位是1，$$2^n-1$$除了最高位变成0，其余位都变成1。这样相当于9和8除最高位的其余位作与，001 & 111 = 1。
